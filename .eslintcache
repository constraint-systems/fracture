[{"/home/grant/dev/fracture/src/index.js":"1","/home/grant/dev/fracture/src/reportWebVitals.js":"2","/home/grant/dev/fracture/src/App.js":"3","/home/grant/dev/fracture/src/State.js":"4","/home/grant/dev/fracture/src/Mouse.js":"5","/home/grant/dev/fracture/src/Keyboard.js":"6","/home/grant/dev/fracture/src/Mobile.js":"7","/home/grant/dev/fracture/src/constants.js":"8","/home/grant/dev/fracture/src/shaders.js":"9","/home/grant/dev/fracture/src/gl_utils.js":"10","/home/grant/dev/fracture/src/Sidebar.js":"11","/home/grant/dev/fracture/src/Gl.js":"12","/home/grant/dev/fracture/src/mat4.js":"13","/home/grant/dev/fracture/src/Examples.js":"14"},{"size":521,"mtime":1609615164670,"results":"15","hashOfConfig":"16"},{"size":362,"mtime":1609013397681,"results":"17","hashOfConfig":"16"},{"size":17191,"mtime":1610595993573,"results":"18","hashOfConfig":"16"},{"size":20820,"mtime":1610318892184,"results":"19","hashOfConfig":"16"},{"size":7080,"mtime":1610506860966,"results":"20","hashOfConfig":"16"},{"size":6935,"mtime":1610559289791,"results":"21","hashOfConfig":"16"},{"size":4029,"mtime":1609899327933,"results":"22","hashOfConfig":"16"},{"size":111,"mtime":1609865182330,"results":"23","hashOfConfig":"16"},{"size":1061,"mtime":1609283436012,"results":"24","hashOfConfig":"16"},{"size":16497,"mtime":1610318831916,"results":"25","hashOfConfig":"16"},{"size":18345,"mtime":1610592953774,"results":"26","hashOfConfig":"16"},{"size":690,"mtime":1609177680124,"results":"27","hashOfConfig":"16"},{"size":9015,"mtime":1609262564992,"results":"28","hashOfConfig":"16"},{"size":6012,"mtime":1610593012181,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"1ooxfhz",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"32"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"32"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"32"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"32"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":47,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"32"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"32"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"32"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67"},"/home/grant/dev/fracture/src/index.js",[],["68","69"],"/home/grant/dev/fracture/src/reportWebVitals.js",[],"/home/grant/dev/fracture/src/App.js",["70","71","72","73","74","75","76","77","78","79","80","81"],"import React, { Fragment, useEffect, useRef, useState } from \"react\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport {\n  aActive,\n  aSize,\n  aGridSize,\n  sViewports,\n  aCols,\n  aRows,\n  aMode,\n  aBarHeight,\n  aSidebarWidth,\n  aCameras,\n  afCamera,\n  aImages,\n  sAddImage,\n  aImageMap,\n  sSetImageMap,\n  sMosaicCamera,\n  sAllCameras,\n  aShowCameras,\n  aShowGrid,\n  aShowPreview,\n} from \"./State.js\";\nimport {\n  setProjectionMatrices,\n  setViewMatrix,\n  getWorldFromPx,\n  setViewMatrices,\n} from \"./gl_utils\";\nimport {\n  RecoilUndoRoot,\n  useUndo,\n  useRedo,\n  useIsTrackingHistory,\n} from \"recoil-undo\";\nimport Keyboard from \"./Keyboard\";\nimport Mouse from \"./Mouse\";\nimport MobileBar from \"./Mobile\";\nimport Sidebar from \"./Sidebar\";\nimport REGL from \"regl\";\nimport { base_zoom, mobile } from \"./constants\";\nimport { initImageQuad } from \"./shaders\";\n\nlet id_counter = 0;\nexport function getID() {\n  id_counter++;\n  return id_counter;\n}\n\nfunction Root() {\n  let scene_ref = useRef({\n    viewports: [],\n    projection: [],\n    inverse_projection: [],\n    views: [],\n    view_projections: [],\n    inverse_view_projections: [],\n    image_map: [],\n    image_draws: [],\n    capture: false,\n  });\n  let input_ref = useRef(null);\n  let scroll_ref = useRef(null);\n  let bypass_ref = useRef(false);\n\n  return (\n    <RecoilRoot>\n      <RecoilUndoRoot trackingByDefault={false}>\n        <input\n          style={{ display: \"none\" }}\n          type=\"file\"\n          accept=\"image/*\"\n          ref={input_ref}\n        />\n        <SizeObserver />\n        <div style={{ position: \"relative\", marginLeft: 4, marginTop: 4 }}>\n          <Canvas\n            scroll_ref={scroll_ref}\n            scene_ref={scene_ref}\n            bypass_ref={bypass_ref}\n          />\n          <Layers />\n        </div>\n        <Actions\n          scene_ref={scene_ref}\n          input_ref={input_ref}\n          bypass_ref={bypass_ref}\n        />\n        <Keyboard\n          scene_ref={scene_ref}\n          input_ref={input_ref}\n          bypass_ref={bypass_ref}\n        />\n      </RecoilUndoRoot>\n    </RecoilRoot>\n  );\n}\n\nexport default Root;\n\nfunction Actions({ input_ref, scene_ref, bypass_ref }) {\n  let [w, h] = useRecoilValue(aSize);\n  return w < mobile ? (\n    <Sidebar\n      mobile={true}\n      scene_ref={scene_ref}\n      input_ref={input_ref}\n      bypass_ref={bypass_ref}\n    />\n  ) : (\n    <Sidebar\n      scene_ref={scene_ref}\n      input_ref={input_ref}\n      bypass_ref={bypass_ref}\n    />\n  );\n}\n\nfunction Layers() {\n  let showPreview = useRecoilValue(aShowPreview);\n  let showCameras = useRecoilValue(aShowCameras);\n  let showGrid = useRecoilValue(aShowGrid);\n  let mode = useRecoilValue(aMode);\n  return (\n    <React.Fragment>\n      {showPreview ? null : showCameras ? <ShowCameras /> : null}\n      {showPreview ? null : showGrid ? <ShowGrid /> : null}\n      {showPreview || mode === \"canvasResize\" ? null : <ShowActive />}\n      {mode === \"canvasResize\" ? <CanvasResize /> : null}\n    </React.Fragment>\n  );\n}\n\nfunction SizeObserver() {\n  let setSize = useSetRecoilState(aSize);\n  let setGridSize = useSetRecoilState(aGridSize);\n  let barHeight = useRecoilValue(aBarHeight);\n  let sidebarWidth = useRecoilValue(aSidebarWidth);\n\n  useEffect(() => {\n    function setNewSize() {\n      let w = window.innerWidth;\n      let h = window.innerHeight;\n      setSize([w, h]);\n      if (w < mobile) {\n        setGridSize([w - 8, h - 48 * 6 - 8]);\n      } else {\n        setGridSize([w - sidebarWidth - 8, h - barHeight - 12]);\n      }\n    }\n    // setSize([4000 - sidebarWidth - 8, 4000 - barHeight - 12]);\n    // setGridSize([4000 - sidebarWidth - 8, 4000 - barHeight - 12]);\n    setNewSize();\n    window.addEventListener(\"resize\", setNewSize);\n    return () => {\n      window.removeEventListener(\"resize\", setNewSize);\n    };\n  }, [setSize, setGridSize]);\n\n  return null;\n}\n\nfunction CanvasResize() {\n  let cols = useRecoilValue(aCols);\n  let rows = useRecoilValue(aRows);\n  let viewports = useRecoilValue(sViewports);\n\n  let v = viewports[0];\n  return (\n    <div\n      className=\"active-outline resize-canvas\"\n      style={{\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        width: cols * v[2],\n        height: rows * v[3],\n        pointerEvents: \"none\",\n        touchEvents: \"none\",\n      }}\n    ></div>\n  );\n}\n\nfunction ShowActive() {\n  let active = useRecoilValue(aActive);\n  let viewports = useRecoilValue(sViewports);\n  let mode = useRecoilValue(aMode);\n\n  let v = viewports[0];\n  return (\n    <div\n      className=\"active-outline\"\n      style={{\n        position: \"absolute\",\n        left: active[0] * v[2],\n        top: active[1] * v[3],\n        width: active[2] * v[2],\n        height: active[3] * v[3],\n        pointerEvents: \"none\",\n        touchEvents: \"none\",\n      }}\n    >\n      {mode === \"resize\" ? (\n        <Fragment>\n          <div\n            style={{\n              position: \"absolute\",\n              left: 0,\n              top: 0,\n              background: \"#111\",\n              width: 17,\n              height: 17,\n              borderBottom: \"solid 1px white\",\n              borderRight: \"solid 1px white\",\n            }}\n          ></div>\n          <div\n            style={{\n              position: \"absolute\",\n              right: 0,\n              bottom: 0,\n              background: \"#111\",\n              width: 17,\n              height: 17,\n              borderTop: \"solid 1px white\",\n              borderLeft: \"solid 1px white\",\n            }}\n          ></div>\n        </Fragment>\n      ) : null}\n    </div>\n  );\n}\n\nfunction ShowCameras() {\n  let viewports = useRecoilValue(sViewports);\n  let camera_ids = useRecoilValue(aCameras);\n\n  return viewports.map((camera, i) => {\n    let v = viewports[i];\n    let id = camera_ids[i];\n    return (\n      <div\n        key={`camera${i}`}\n        style={{\n          position: \"absolute\",\n          left: v[0],\n          top: v[1],\n          width: v[2],\n          height: v[3],\n          pointerEvents: \"none\",\n          touchEvents: \"none\",\n        }}\n      >\n        <CameraRead id={id} />\n      </div>\n    );\n  });\n}\n\nfunction ShowGrid() {\n  let [width, height] = useRecoilValue(aGridSize);\n  let cols = useRecoilValue(aCols);\n  let rows = useRecoilValue(aRows);\n  let showPreview = useRecoilValue(aShowPreview);\n  let vw = Math.floor(width / cols);\n  let vh = Math.floor(height / rows);\n  let crop_width = vw * cols;\n  let crop_height = vh * rows;\n  let bl = 160;\n  return (\n    <div>\n      {cols > 0\n        ? [...Array(cols - 1)].map((_, c) => {\n            return (\n              <React.Fragment key={`colback_${c}`}>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: (c + 1) * vw - 1.5,\n                    top: 0,\n                    width: 3,\n                    height: crop_height,\n                    background: \"rgba(20,20,20,0.5)\",\n                  }}\n                ></div>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: (c + 1) * vw - 0.5,\n                    top: 0,\n                    width: 1,\n                    height: crop_height,\n                    background: \"rgba(\" + [bl, bl, bl] + \",0.5)\",\n                  }}\n                ></div>\n              </React.Fragment>\n            );\n          })\n        : null}\n\n      {rows > 0\n        ? [...Array(rows - 1)].map((_, r) => {\n            return (\n              <React.Fragment key={`rowback_${r}`}>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: 0,\n                    top: (r + 1) * vh - 1.5,\n                    height: 3,\n                    width: crop_width,\n                    background: \"rgba(20,20,20,0.5)\",\n                  }}\n                ></div>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: 0,\n                    top: (r + 1) * vh - 0.5,\n                    height: 1,\n                    width: crop_width,\n                    background: \"rgba(\" + [bl, bl, bl] + \",0.5)\",\n                  }}\n                ></div>\n              </React.Fragment>\n            );\n          })\n        : null}\n    </div>\n  );\n}\n\nfunction CameraRead({ id }) {\n  let camera = useRecoilValue(afCamera(id));\n  return (\n    <div\n      className=\"outline-text\"\n      style={{\n        position: \"absolute\",\n        fontSize: 12,\n        left: 0,\n        bottom: 8,\n        paddingLeft: 8,\n        paddingRight: 8,\n        color: \"#eee\",\n        userSelect: \"none\",\n        width: \"100%\",\n        overflow: \"hidden\",\n      }}\n    >\n      {camera\n        .map((v) => Math.round((v + Number.EPSILON) * 100) / 100)\n        .join(\",\")}\n    </div>\n  );\n}\n\nexport function loadImage(scene, src, addImage, presetImageMap, callback) {\n  let $img = new Image();\n  $img.onload = function () {\n    // might be a race condition\n    scene.pixel = getWorldFromPx(scene, 1, base_zoom);\n    let w = $img.width * scene.pixel;\n    let h = $img.height * scene.pixel;\n    let x0 = -w / 2;\n    let y0 = h / 2;\n    let x1 = w / 2;\n    let y1 = -h / 2;\n    let place = [x0, y0, x1, y1];\n    addImage($img);\n    let drawImage = initImageQuad(scene, $img, ...place);\n    scene.image_draws.push(drawImage);\n    if (presetImageMap !== undefined) presetImageMap();\n    if (callback !== undefined) {\n      callback();\n    }\n  };\n  $img.src = src;\n}\n\nexport function domLoadImage(scene, input, addImage, presetImageMap) {\n  function handleChange(e) {\n    for (let item of this.files) {\n      if (item.type.indexOf(\"image\") < 0) {\n        continue;\n      }\n      let src = URL.createObjectURL(item);\n      loadImage(scene, src, addImage, presetImageMap);\n      input.value = null;\n    }\n    input.removeEventListener(\"change\", handleChange);\n  }\n  input.addEventListener(\"change\", handleChange);\n\n  input.dispatchEvent(\n    new MouseEvent(\"click\", {\n      bubbles: true,\n      cancelable: true,\n      view: window,\n    })\n  );\n}\n\nfunction Canvas({ scene_ref, scroll_ref, bypass_ref }) {\n  let gridSize = useRecoilValue(aGridSize);\n  let viewports = useRecoilValue(sViewports);\n  let cols = useRecoilValue(aCols);\n  let rows = useRecoilValue(aRows);\n  let sidebarWidth = useRecoilValue(aSidebarWidth);\n  let allCameras = useRecoilValue(sAllCameras);\n  let images = useRecoilValue(aImages);\n  let barHeight = useRecoilValue(aBarHeight);\n  let addImage = useSetRecoilState(sAddImage);\n  let [imageMap, rawSetImageMap] = useRecoilState(aImageMap);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let mosaicCamera = useSetRecoilState(sMosaicCamera);\n  let [cameras, setCameras] = useRecoilState(aCameras);\n  let canvas_ref = useRef(null);\n  let regl_ref = useRef(null);\n  let size = useRecoilValue(aSize);\n  let [loaded, setLoaded] = useState(false);\n  const { getIsTrackingHistory, setIsTrackingHistory } = useIsTrackingHistory();\n\n  useEffect(() => {\n    if (gridSize[0] !== null && !loaded) {\n      let regl = REGL(canvas_ref.current);\n      regl_ref.current = regl;\n      let scene = scene_ref.current;\n      scene.regl = regl;\n\n      // init cameras and scene arrays\n      let camera_ids = [];\n      for (let i = 0; i < cols * rows; i++) {\n        let id = getID();\n        camera_ids.push(id);\n        scene.views.push([]);\n        scene.view_projections.push([]);\n        scene.inverse_view_projections.push([]);\n        scene.image_map.push(null);\n      }\n      setCameras(camera_ids);\n      scene.cameras = [...Array(cols * rows)].map((v) => [0, 0, 5]);\n\n      rawSetImageMap([...Array(cols * rows)].map((v) => null));\n\n      setScene(scene, cols, rows, gridSize, viewports, allCameras);\n\n      loadImage(\n        scene,\n        process.env.PUBLIC_URL + \"/images/ozymandias-screens-watchmen.jpg\",\n        addImage,\n        setImageMap.bind(null, { active: [0, 0, cols, rows] }),\n        () => {\n          mosaicCamera({ scene, active: [0, 0, cols, rows] });\n          setIsTrackingHistory(true);\n        }\n      );\n\n      let gl = canvas_ref.current.getContext(\"webgl\");\n      gl.enable(gl.SCISSOR_TEST);\n\n      regl.frame(({ tick }) => {\n        regl.clear({\n          color: [0, 0, 0, 1],\n        });\n        if (scene.viewports.length > 0) {\n          let vy_offset =\n            scene.gridSize[1] - scene.viewports[0][3] * scene.rows;\n          for (let i = 0; i < scene.viewports.length; i++) {\n            let viewport = scene.viewports[i];\n            let [vx, vy, vw, vh] = viewport;\n            // gap at bottom instead of top\n            vy = vy + vy_offset;\n            gl.viewport(vx, vy, vw, vh);\n            gl.scissor(vx, vy, vw, vh);\n            regl.clear({\n              color: [0, 0, 0, 1],\n            });\n            if (scene.image_map.length > 0 && scene.image_map[i] !== null) {\n              let draw = scene.image_draws[scene.image_map[i]];\n              draw({\n                view_projection: scene.view_projections[i],\n              });\n            }\n          }\n        }\n\n        if (scene.capture) {\n          scene.capture = false;\n          let save_canvas = document.createElement(\"canvas\");\n          save_canvas.width = scene.viewports[0][2] * scene.cols;\n          save_canvas.height = scene.viewports[0][3] * scene.rows;\n          let sx = save_canvas.getContext(\"2d\");\n          sx.drawImage(gl.canvas, 0, 0);\n          let link = document.createElement(\"a\");\n          save_canvas.toBlob(function (blob) {\n            link.setAttribute(\n              \"download\",\n              \"fracture-\" + Math.round(new Date().getTime() / 1000) + \".png\"\n            );\n            link.setAttribute(\"href\", URL.createObjectURL(blob));\n            link.dispatchEvent(\n              new MouseEvent(`click`, {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n              })\n            );\n          });\n        }\n      });\n      setLoaded(true);\n    }\n  }, [gridSize, loaded]);\n\n  useEffect(() => {\n    if (loaded) {\n      let scene = scene_ref.current;\n      scene.image_map = imageMap;\n    }\n  }, [loaded, imageMap]);\n\n  useEffect(() => {\n    if (loaded) {\n      setScene(scene_ref.current, cols, rows, gridSize, viewports, allCameras);\n    }\n  }, [loaded, cols, rows, gridSize, viewports, cameras]);\n\n  return gridSize[0] !== null ? (\n    <div\n      ref={scroll_ref}\n      style={{\n        width: gridSize[0] + (size[0] > mobile ? sidebarWidth : 0) + 4,\n        height: gridSize[1] + (size[0] > mobile ? barHeight + 8 : 4),\n        userSelect: \"none\",\n        touchAction: \"none\",\n      }}\n    >\n      <canvas width={gridSize[0]} height={gridSize[1]} ref={canvas_ref}>\n        {cameras.map((id, index) => (\n          <CanvasCamera key={id} id={id} index={index} scene_ref={scene_ref} />\n        ))}\n        <Mouse\n          canvas_ref={canvas_ref}\n          scene_ref={scene_ref}\n          scroll_ref={scroll_ref}\n        />\n      </canvas>\n    </div>\n  ) : null;\n}\n\nexport function setScene(scene, cols, rows, gridSize, viewports, allCameras) {\n  let rawCameras = allCameras.slice();\n  let invertedCameras = [];\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      let index = r * cols + c;\n      let invert_row = rows - 1 - Math.floor(index / cols);\n      let inverted = invert_row * cols + (index % cols);\n      invertedCameras.push(rawCameras[inverted]);\n    }\n  }\n\n  scene.cameras = invertedCameras;\n  scene.gridSize = gridSize;\n  scene.cols = cols;\n  scene.rows = rows;\n  scene.viewports = viewports;\n\n  setProjectionMatrices(scene);\n\n  scene.views = [];\n  scene.view_projections = [];\n  scene.inverse_view_projections = [];\n  for (let i = 0; i < cols * rows; i++) {\n    scene.views.push([]);\n    scene.view_projections.push([]);\n    scene.inverse_view_projections.push([]);\n  }\n  setViewMatrices(scene);\n}\n\nfunction CanvasCamera({ id, index, scene_ref }) {\n  let camera = useRecoilValue(afCamera(id));\n\n  useEffect(() => {\n    let scene = scene_ref.current;\n\n    let invert_row = scene.rows - 1 - Math.floor(index / scene.cols);\n    let inverted = invert_row * scene.cols + (index % scene.cols);\n\n    scene.cameras[inverted] = camera;\n    setViewMatrix(scene, inverted);\n  }, [id, index, camera, scene_ref]);\n\n  return null;\n}\n\nfunction ReadActive() {\n  let [x, y, w, h] = useRecoilValue(aActive);\n  let [gw, gh] = useRecoilValue(aGridSize);\n  let size = useRecoilValue(aSize);\n  let mode = useRecoilValue(aMode);\n  return size[0] > mobile ? (\n    <div style={{ position: \"fixed\", left: 0, bottom: 0, display: \"flex\" }}>\n      {mode === \"canvasResize\" ? (\n        <div style={{ background: \"#111\", padding: 8 }}>\n          {gw}x{gh}\n        </div>\n      ) : (\n        <div style={{ background: \"#111\", padding: 8 }}>\n          â–¡ {x},{y} {w}x{h}\n        </div>\n      )}\n    </div>\n  ) : null;\n}\n","/home/grant/dev/fracture/src/State.js",["82","83","84","85","86","87","88"],"import React from \"react\";\nimport { atom, atomFamily, selector } from \"recoil\";\nimport { getWorldFromPx, castRay } from \"./gl_utils\";\nimport { base_zoom, zoom_scaler } from \"./constants\";\nimport { getID } from \"./App\";\n\nexport let aScene = atom({\n  key: \"scene\",\n  default: {},\n});\n\nexport let aActive = atom({\n  key: \"active\",\n  default: [2, 1, 1, 1],\n});\n\nexport let a_Mode = atom({\n  key: \"mode\",\n  default: \"normal\",\n});\n\nexport let aMode = selector({\n  key: \"sMode\",\n  get: ({ get }) => {\n    return get(a_Mode);\n  },\n  set: ({ set }, name) => {\n    set(a_Mode, name);\n  },\n});\n\nexport let aSize = atom({\n  key: \"size\",\n  default: [null, null],\n});\n\nexport let aGridSize = atom({\n  key: \"gridSize\",\n  default: [null, null],\n});\n\nexport let sGridSize = selector({\n  key: \"changeGridSize\",\n  set: ({ get, set }, diff) => {\n    let [dx, dy] = diff;\n    let [w, h] = get(aGridSize).slice();\n    let wlimit = Math.max(64, w + dx * 8);\n    let hlimit = Math.max(64, h + dy * 8);\n    set(aGridSize, [wlimit, hlimit]);\n  },\n});\n\nexport let aCols = atom({\n  key: \"cols\",\n  default: 4,\n});\n\nexport let aRows = atom({\n  key: \"rows\",\n  default: 4,\n});\n\nexport let aBarHeight = atom({\n  key: \"barHeight\",\n  default: 0,\n});\n\nexport let aSidebarWidth = atom({\n  key: \"sidebarWidth\",\n  default: 360,\n});\n\nexport let aCameras = atom({\n  key: \"cameras\",\n  default: [],\n});\n\nexport let afCamera = atomFamily({\n  key: \"camera\",\n  default: [0, 0, 5],\n});\n\nexport let aImageMap = atom({\n  key: \"imageMap\",\n  default: [],\n});\n\nexport let aImages = atom({\n  key: \"images\",\n  default: [],\n});\n\nexport let sAddImage = selector({\n  key: \"addImage\",\n  set: ({ get, set }, img) => {\n    let imgs = get(aImages);\n    set(aImages, [...imgs, img]);\n  },\n});\n\nfunction constrainActive(active, cols, rows) {\n  let [x, y, w, h] = active;\n  if (w > cols) w = cols;\n  if (h > rows) h = rows;\n  return [minmax(x, 0, cols - w), minmax(y, 0, rows - h), w, h];\n}\n\nfunction minmax(val, min, max) {\n  return Math.max(min, Math.min(max, val));\n}\n\nexport let sActiveSelector = selector({\n  key: \"activeSelector\",\n  set: ({ get, set }, new_value) => {\n    set(aActive, constrainActive(new_value, get(aCols), get(aRows)));\n  },\n});\n\nexport let sSelectAll = selector({\n  key: \"selectAll\",\n  set: ({ get, set }, new_value) => {\n    set(aActive, [0, 0, get(aCols), get(aRows)]);\n  },\n});\n\nexport let sMoveActiveSelector = selector({\n  key: \"moveActiveSelector\",\n  set: ({ get, set }, diff) => {\n    let [x, y, w, h] = get(aActive);\n    let [dx, dy] = diff;\n    set(sActiveSelector, [x + dx, y + dy, w, h]);\n  },\n});\n\nfunction constrainResize(active, cols, rows) {\n  let [x, y, w, h] = active;\n  let wlimit = cols - active[0];\n  let hlimit = rows - active[1];\n  return [x, y, minmax(w, 1, wlimit), minmax(h, 1, hlimit)];\n}\n\nexport let sResizeActiveSelector = selector({\n  key: \"resizeActiveSelector\",\n  set: ({ get, set }, diff) => {\n    let [x, y, w, h] = get(aActive);\n    let [dx, dy] = diff;\n    let new_value = [x, y, w + dx, h + dy];\n    set(aActive, constrainResize(new_value, get(aCols), get(aRows)));\n  },\n});\n\nexport let sViewports = selector({\n  key: \"viewports\",\n  get: ({ get }) => {\n    let [w, h] = get(aGridSize);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let vw = Math.floor(w / cols);\n    let vh = Math.floor(h / rows);\n    return [...Array(cols * rows)].map((_, i) => {\n      let c = i % cols;\n      let r = Math.floor(i / cols);\n      return [c * vw, r * vh, vw, vh];\n    });\n  },\n});\n\nexport let sPanCamera = selector({\n  key: \"panCamera\",\n  set: ({ get, set }, { scene, diff }) => {\n    let [dx, dy] = diff;\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let [x, y, w, h] = get(aActive);\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let ndx = getWorldFromPx(scene, dx, new_camera[2]);\n        let ndy = getWorldFromPx(scene, dy, new_camera[2]);\n        new_camera[0] -= ndx;\n        new_camera[1] += ndy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sActiveEscape = selector({\n  key: \"activeEscape\",\n  set: ({ get, set }) => {\n    let [x, y, w, h] = get(aActive);\n    set(aActive, [x, y, 1, 1]);\n  },\n});\n\nexport let sResetZoom = selector({\n  key: \"resetZoom\",\n  set: ({ get, set }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let [x, y, w, h] = get(aActive);\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        new_camera[2] = base_zoom;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sAllCameras = selector({\n  key: \"allCameras\",\n  get: ({ get }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let expandedCameras = [];\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols; c++) {\n        let index = r * cols + c;\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        expandedCameras.push(camera);\n      }\n    }\n    return expandedCameras;\n  },\n});\n\nexport let sMosaicCamera = selector({\n  key: \"mosaicCamera\",\n  set: ({ get, set }, { scene, active }) => {\n    let cameras = get(aCameras);\n    let viewports = get(sViewports);\n    let [gw, gh] = get(aGridSize);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let get_active;\n    if (active === undefined) {\n      get_active = get(aActive);\n    } else {\n      get_active = active;\n    }\n    let [x, y, w, h] = get_active;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        let id = cameras[index];\n        let [vx, vy, vw, vh] = viewports[inverted];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let midx = vx + vw / 2;\n        let midy = vy + vh / 2;\n        let difx = midx - gw / 2;\n        let dify = midy - gh / 2;\n        let w = getWorldFromPx(scene, difx, new_camera[2]);\n        let h = getWorldFromPx(scene, dify, new_camera[2]);\n        new_camera[0] = w;\n        new_camera[1] = h;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sShakeCamera = selector({\n  key: \"shakeCamera\",\n  set: ({ get, set }, { scene, active }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let get_active;\n    if (active === undefined) {\n      get_active = get(aActive);\n    } else {\n      get_active = active;\n    }\n    let [x, y, w, h] = get_active;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let nd = getWorldFromPx(scene, 24, new_camera[2]);\n        let dx = 0 - nd / 2 + Math.random() * nd;\n        let dy = 0 - nd / 2 + Math.random() * nd;\n        new_camera[0] += dx;\n        new_camera[1] += dy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sPushCameras = selector({\n  key: \"pushCameras\",\n  set: ({ get, set }, { scene, active }) => {\n    let [x, y, w, h] = get(aActive);\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let c1 = x + w / 2;\n    let c2 = y + h / 2;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let dx = 0;\n        let dy = 0;\n        if (c1 < c + x + 0.5) {\n          dx = -1;\n        } else if (c1 > c + x + 0.5) {\n          dx = 1;\n        }\n        if (c2 < r + y + 0.5) {\n          dy = 1;\n        } else if (c2 > r + y + 0.5) {\n          dy = -1;\n        }\n        let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n        let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n        new_camera[0] += ndx;\n        new_camera[1] += ndy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sPullCameras = selector({\n  key: \"pullCameras\",\n  set: ({ get, set }, { scene, active }) => {\n    let [x, y, w, h] = get(aActive);\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let c1 = x + w / 2;\n    let c2 = y + h / 2;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let dx = 0;\n        let dy = 0;\n        if (c1 < c + x + 0.5) {\n          dx = 1;\n        } else if (c1 > c + x + 0.5) {\n          dx = -1;\n        }\n        if (c2 < r + y + 0.5) {\n          dy = -1;\n        } else if (c2 > r + y + 0.5) {\n          dy = 1;\n        }\n        let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n        let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n        new_camera[0] += ndx;\n        new_camera[1] += ndy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sShatterCamera = selector({\n  key: \"shatterCamera\",\n  set: ({ get, set }, scene) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let [x, y, w, h] = get(aActive);\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        new_camera[0] = 0;\n        new_camera[1] = 0;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sSetImageMap = selector({\n  key: \"setImageMap\",\n  set: ({ get, set }, { active }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let get_active;\n    if (active === undefined) {\n      get_active = get(aActive);\n    } else {\n      get_active = active;\n    }\n    let [x, y, w, h] = get_active;\n    let images = get(aImages);\n    let new_map = get(aImageMap).slice();\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        new_map[inverted] = images.length - 1;\n      }\n    }\n    set(aImageMap, new_map);\n  },\n});\n\nfunction zoomLimit(new_zoom) {\n  let max = 100;\n  let min = 0.01;\n  return Math.min(max, Math.max(min, new_zoom));\n}\n\nexport let aZoomMode = atom({\n  key: \"zoomMode\",\n  default: \"canvas\",\n});\n\nexport let aShowCameras = atom({\n  key: \"showCameras\",\n  default: false,\n});\n\nexport let aShowGrid = atom({\n  key: \"showGrid\",\n  default: true,\n});\n\nexport let aShowPreview = atom({\n  key: \"showPreview\",\n  default: false,\n});\n\nexport let aCopy = atom({\n  key: \"copy\",\n  default: [],\n});\n\nexport let sCopy = selector({\n  key: \"setCopy\",\n  set: ({ get, set }) => {\n    let [x, y, w, h] = get(aActive);\n    let imageMap = get(aImageMap);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let cameras = get(aCameras);\n    let copy = [];\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let map = imageMap[inverted];\n        let obj = [camera.slice(), map];\n        copy.push(obj);\n      }\n    }\n    set(aCopy, copy);\n  },\n});\n\nexport let sPaste = selector({\n  key: \"setPaste\",\n  set: ({ get, set }) => {\n    let copy = get(aCopy);\n    if (copy.length > 0) {\n      let [x, y, w, h] = get(aActive);\n      let imageMap = get(aImageMap);\n      let newMap = imageMap.slice();\n      let cols = get(aCols);\n      let rows = get(aRows);\n      let cameras = get(aCameras);\n      let copy = get(aCopy);\n      for (let r = 0; r < h; r++) {\n        for (let c = 0; c < w; c++) {\n          let copyIndex = r * w + c;\n          if (copy[copyIndex] === undefined) copyIndex = copy.length - 1;\n          let [new_camera, new_map] = copy[copyIndex];\n          let index = (y + r) * cols + (x + c);\n          let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n          let id = cameras[index];\n          newMap[inverted] = new_map;\n          set(afCamera(id), new_camera);\n        }\n      }\n      set(aImageMap, newMap);\n    }\n  },\n});\n\nexport let sZoomCamera = selector({\n  key: \"zoomCamera\",\n  set: ({ get, set }, { scene, sign, mult }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let [x, y, w, h] = get(aActive);\n    let [gw, gh] = get(aGridSize);\n    let zoomMode = get(aZoomMode);\n    let viewports = get(sViewports);\n    let [xp, yp] = viewports[(rows - (y + h)) * cols + x];\n    let [_, __, vw, vh] = viewports[0];\n    let active_size = [vw * w, vh * h];\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let zoom = new_camera[2];\n        let new_poss;\n        if (sign > 0) {\n          new_poss = zoom * mult;\n        } else {\n          new_poss = zoom / mult;\n        }\n        let new_zoom = zoomLimit(new_poss);\n        if (new_zoom > zoom || new_zoom < zoom) {\n          if (zoomMode === \"canvas\") {\n            let projected = castRay(\n              scene,\n              inverted,\n              [gw / 2, gh / 2],\n              new_zoom\n            );\n            new_camera = [...projected, new_zoom];\n          } else if (zoomMode === \"active\") {\n            let projected = castRay(\n              scene,\n              inverted,\n              [xp + active_size[0] / 2, yp + active_size[1] / 2],\n              new_zoom\n            );\n            new_camera = [...projected, new_zoom];\n          } else {\n            new_camera[2] = new_zoom;\n          }\n          set(afCamera(id), new_camera);\n        }\n      }\n    }\n  },\n});\n\nexport let sAddCol = selector({\n  key: \"addCol\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (cols < 10) {\n      let [x, y, w, h] = get(aActive);\n      let insertCol = x + w;\n      let lastCol = insertCol - 1;\n\n      let imageMap = get(aImageMap);\n      let mapCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapCols[c].push(imageMap[index]);\n        }\n      }\n      let copyCol = mapCols[lastCol].slice();\n      mapCols.splice(insertCol, 0, copyCol);\n      let recombinedMap = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < mapCols.length; c++) {\n          recombinedMap.push(mapCols[c][r]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraCols[c].push(cameras[index]);\n        }\n      }\n      let copyCameras = cameraCols[lastCol].slice();\n      let newCol = [];\n      for (let r = 0; r < rows; r++) {\n        let id = getID();\n        let copyID = copyCameras[r];\n        let cloneCamera = get(afCamera(copyID)).slice();\n        set(afCamera(id), cloneCamera);\n        newCol.push(id);\n      }\n      cameraCols.splice(insertCol, 0, newCol);\n      let recombinedCameras = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cameraCols.length; c++) {\n          recombinedCameras.push(cameraCols[c][r]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aCols, cols + 1);\n      set(aActive, [x, y, w + 1, h]);\n    }\n  },\n});\n\nexport let sRemCol = selector({\n  key: \"remCol\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (cols > 1) {\n      let [x, y, w, h] = get(aActive);\n      let firstCol = x;\n\n      let imageMap = get(aImageMap);\n      let mapCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapCols[c].push(imageMap[index]);\n        }\n      }\n      mapCols.splice(firstCol, 1);\n      let recombinedMap = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < mapCols.length; c++) {\n          recombinedMap.push(mapCols[c][r]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraCols[c].push(cameras[index]);\n        }\n      }\n      cameraCols.splice(firstCol, 1);\n      let recombinedCameras = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cameraCols.length; c++) {\n          recombinedCameras.push(cameraCols[c][r]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aCols, cols - 1);\n      if (w > 1) {\n        set(aActive, constrainActive([x, y, w - 1, h], cols - 1, rows));\n      } else {\n        set(aActive, constrainActive([x - 1, y, w, h], cols - 1, rows));\n      }\n    }\n  },\n});\n\nexport let sAddRow = selector({\n  key: \"addRow\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (rows < 8) {\n      let [x, y, w, h] = get(aActive);\n      let insertRow = y + h;\n      let lastRow = insertRow - 1;\n\n      let imageMap = get(aImageMap);\n      let mapRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapRows[r].push(imageMap[index]);\n        }\n      }\n      let copyRow = mapRows[lastRow].slice();\n      mapRows.splice(insertRow, 0, copyRow);\n      let recombinedMap = [];\n      for (let r = 0; r < mapRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedMap.push(mapRows[r][c]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraRows[r].push(cameras[index]);\n        }\n      }\n      let copyCameras = cameraRows[lastRow].slice();\n      let newRow = [];\n      for (let c = 0; c < cols; c++) {\n        let id = getID();\n        let copyID = copyCameras[c];\n        let cloneCamera = get(afCamera(copyID)).slice();\n        set(afCamera(id), cloneCamera);\n        newRow.push(id);\n      }\n      cameraRows.splice(insertRow, 0, newRow);\n      let recombinedCameras = [];\n      for (let r = 0; r < cameraRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedCameras.push(cameraRows[r][c]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aRows, rows + 1);\n      set(aActive, [x, y, w, h + 1]);\n    }\n  },\n});\n\nexport let sRemRow = selector({\n  key: \"remRoww\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (rows > 1) {\n      let [x, y, w, h] = get(aActive);\n      let firstRow = y;\n\n      let imageMap = get(aImageMap);\n      let mapRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapRows[r].push(imageMap[index]);\n        }\n      }\n      mapRows.splice(firstRow, 1);\n      let recombinedMap = [];\n      for (let r = 0; r < mapRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedMap.push(mapRows[r][c]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraRows[r].push(cameras[index]);\n        }\n      }\n      cameraRows.splice(firstRow, 1);\n      let recombinedCameras = [];\n      for (let r = 0; r < cameraRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedCameras.push(cameraRows[r][c]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aRows, rows - 1);\n      if (h > 1) {\n        set(aActive, constrainActive([x, y, w, h - 1], cols, rows - 1));\n      } else {\n        set(aActive, constrainActive([x - 1, y, w, h], cols, rows - 1));\n      }\n    }\n  },\n});\n","/home/grant/dev/fracture/src/Mouse.js",["89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104"],"import React, { useState, useEffect, useRef } from \"react\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport { draw } from \"./Gl.js\";\nimport {\n  aActive,\n  sViewports,\n  sPanCamera,\n  aCols,\n  sActiveSelector,\n  sSetImageMap,\n  sZoomCamera,\n  aMode,\n  sAddImage,\n} from \"./State.js\";\nimport { useBatching } from \"recoil-undo\";\nimport { loadImage } from \"./App\";\n\nfunction debounce(func, wait, immediate) {\n  var timeout;\n  return function () {\n    var context = this,\n      args = arguments;\n    var later = function () {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n\nfunction throttle(callback, limit) {\n  var waiting = false; // Initially, we're not waiting\n  return function () {\n    // We return a throttled function\n    if (!waiting) {\n      // If we're not waiting\n      callback.apply(this, arguments); // Execute users function\n      waiting = true; // Prevent future invocations\n      setTimeout(function () {\n        // After a period of time\n        waiting = false; // And allow future invocations\n      }, limit);\n    }\n  };\n}\n\nfunction Mouse({ canvas_ref, scene_ref, scroll_ref }) {\n  let mouse_ref = useRef({\n    raw: [0, 0],\n    down: false,\n    drag_start: null,\n    scrollCheck: [0, 0],\n  });\n  let viewports = useRecoilValue(sViewports);\n  let panCamera = useSetRecoilState(sPanCamera);\n  let active = useRecoilValue(aActive);\n  let cols = useRecoilValue(aCols);\n  let mode = useRecoilValue(aMode);\n  let setActive = useSetRecoilState(sActiveSelector);\n  let zoomCamera = useSetRecoilState(sZoomCamera);\n  let addImage = useSetRecoilState(sAddImage);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let { startBatch, endBatch } = useBatching();\n\n  useEffect(() => {\n    function getViewportFromMouse(mouse_raw) {\n      let [mx, my] = mouse_raw;\n      for (let i = 0; i < viewports.length; i++) {\n        let viewport = viewports[i];\n        let [x, y, w, h] = viewport;\n        let col = i % cols;\n        let row = Math.floor(i / cols);\n        if (mx >= x && mx <= x + w && my >= y && my <= y + h) {\n          return [col, row];\n        }\n      }\n    }\n\n    let canvas = canvas_ref.current;\n    let mouse = mouse_ref.current;\n    let scene = scene_ref.current;\n    let scroll = scroll_ref.current;\n\n    function mouseMove(e) {\n      e.preventDefault();\n      if (e.clientX !== mouse.raw[0] && e.clientY !== mouse.raw[1]) {\n        if (mouse.scroll) {\n          let dx = e.clientX - mouse.scrollCheck[0];\n          let dy = e.clientY - mouse.scrollCheck[1];\n          window.scrollBy(-dx, -dy);\n          mouse.scrollCheck = [e.clientX, e.clientY];\n          return false;\n        }\n        var rect = e.target.getBoundingClientRect();\n        var x = e.clientX - rect.left;\n        var y = e.clientY - rect.top;\n        if (mouse.down) {\n          if (mode === \"resize\") {\n            let [ax, ay, aw, ah] = active;\n            let [mx, my] = getViewportFromMouse(mouse.raw);\n            let ax2 = ax + aw - 1;\n            let ay2 = ay + ah - 1;\n            let nx = Math.min(mx, ax);\n            let ny = Math.min(my, ay);\n            let nx2 = Math.max(mx, ax2);\n            let ny2 = Math.max(my, ay2);\n            let w = nx2 - nx + 1;\n            let h = ny2 - ny + 1;\n            setActive([nx, ny, w, h]);\n          } else {\n            let dx = x - mouse.raw[0];\n            let dy = y - mouse.raw[1];\n            panCamera({ scene, diff: [dx, dy] });\n          }\n        }\n        mouse.raw = [x, y];\n      }\n    }\n    function mouseDown(e) {\n      e.preventDefault();\n      // startBatch();\n      if (e.ctrlKey) {\n        mouse.scroll = true;\n        canvas.setPointerCapture(e.pointerId);\n        mouse.scrollCheck = [e.clientX, e.clientY];\n        return false;\n      }\n      var rect = e.target.getBoundingClientRect();\n      var x = e.clientX - rect.left; //x position within the element.\n      var y = e.clientY - rect.top;\n      mouse.raw = [x, y];\n      if (mode === \"resize\") {\n        let [ax, ay, aw, ah] = active;\n        let [mcol, mrow] = getViewportFromMouse(mouse.raw);\n        setActive([mcol, mrow, 1, 1]);\n        mouse.down = true;\n      } else if (mode === \"normal\") {\n        let [ax, ay, aw, ah] = active;\n        let [mcol, mrow] = getViewportFromMouse(mouse.raw);\n        if (mcol >= ax && mcol < ax + aw && mrow >= ay && mrow < ay + ah) {\n          mouse.down = true;\n        } else {\n          setActive([\n            mcol - Math.round((aw - 1) / 2),\n            mrow - Math.round((ah - 1) / 2),\n            aw,\n            ah,\n          ]);\n          mouse.down = true;\n        }\n      }\n      canvas.setPointerCapture(e.pointerId);\n    }\n    function mouseUp(e) {\n      e.preventDefault();\n      // endBatch();\n      mouse.down = false;\n      mouse.scroll = false;\n      canvas.releasePointerCapture(e.pointerId);\n    }\n    function mouseWheel(e) {\n      e.preventDefault();\n\n      if (mode === \"normal\") {\n        let sign = e.deltaY < 0 ? -1 : 1;\n        let mult = 1;\n        let abs = Math.abs(e.deltaY);\n        if (abs > 25) {\n          mult = 1.125;\n        } else {\n          mult = 1 + 0.125 * (abs / 80);\n        }\n        zoomCamera({ scene, sign, mult });\n      }\n    }\n\n    function onDrop(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      let file = e.dataTransfer.files[0];\n      let filename = file.path ? file.path : file.name ? file.name : \"\";\n      let src = URL.createObjectURL(file);\n      loadImage(scene, src, addImage);\n    }\n\n    function onDrag(e) {\n      e.stopPropagation();\n      e.preventDefault();\n      e.dataTransfer.dropEffect = \"copy\";\n    }\n\n    function onPaste(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log(\"paste\");\n      for (const item of e.clipboardData.items) {\n        if (item.type.indexOf(\"image\") < 0) {\n          continue;\n        }\n        let file = item.getAsFile();\n        let src = URL.createObjectURL(file);\n        loadImage(scene, src, addImage, setImageMap.bind(null, {}));\n      }\n    }\n\n    canvas.addEventListener(\"pointermove\", mouseMove);\n    canvas.addEventListener(\"pointerdown\", mouseDown);\n    canvas.addEventListener(\"pointerup\", mouseUp);\n    canvas.addEventListener(\"wheel\", mouseWheel, { passive: false });\n    window.addEventListener(\"paste\", onPaste);\n    window.addEventListener(\"dragover\", onDrag);\n    window.addEventListener(\"drop\", onDrop);\n    return () => {\n      canvas.removeEventListener(\"pointermove\", mouseMove);\n      canvas.removeEventListener(\"pointerdown\", mouseDown);\n      canvas.removeEventListener(\"pointerup\", mouseUp);\n      canvas.removeEventListener(\"wheel\", mouseWheel);\n      window.removeEventListener(\"paste\", onPaste);\n      window.removeEventListener(\"dragover\", onDrag);\n      window.removeEventListener(\"drop\", onDrop);\n    };\n  }, [viewports, mode, canvas_ref, active, cols]);\n\n  return null;\n}\n\nexport default Mouse;\n","/home/grant/dev/fracture/src/Keyboard.js",["105","106","107","108","109","110","111","112"],"import { useEffect, useRef, useState } from \"react\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n  useRecoilSnapshot,\n  useRecoilCallback,\n} from \"recoil\";\nimport {\n  aMode,\n  sMoveActiveSelector,\n  sResizeActiveSelector,\n  sPanCamera,\n  sZoomCamera,\n  sMosaicCamera,\n  sShatterCamera,\n  sSelectAll,\n  sShakeCamera,\n  sPushCameras,\n  sPullCameras,\n  sAddCol,\n  sRemCol,\n  sAddRow,\n  sRemRow,\n  sResetZoom,\n  sActiveEscape,\n  sAddImage,\n  sSetImageMap,\n  aShowCameras,\n  aShowGrid,\n  aZoomMode,\n  aShowPreview,\n  sCopy,\n  sPaste,\n  sGridSize,\n  sAllCameras,\n  aCols,\n  aRows,\n} from \"./State.js\";\nimport { useUndo, useRedo } from \"recoil-undo\";\nimport { domLoadImage } from \"./App\";\n\nfunction Keyboard({ scene_ref, input_ref }) {\n  let [mode, setMode] = useRecoilState(aMode);\n  let moveActive = useSetRecoilState(sMoveActiveSelector);\n  let resizeActive = useSetRecoilState(sResizeActiveSelector);\n  let [zoomMode, setZoomMode] = useRecoilState(aZoomMode);\n  let [showCameras, setShowCameras] = useRecoilState(aShowCameras);\n  let [showGrid, setShowGrid] = useRecoilState(aShowGrid);\n  let [showPreview, setShowPreview] = useRecoilState(aShowPreview);\n  let zoomCamera = useSetRecoilState(sZoomCamera);\n  let panCamera = useSetRecoilState(sPanCamera);\n  let mosaicCamera = useSetRecoilState(sMosaicCamera);\n  let shatterCamera = useSetRecoilState(sShatterCamera);\n  let shakeCamera = useSetRecoilState(sShakeCamera);\n  let pushCameras = useSetRecoilState(sPushCameras);\n  let pullCameras = useSetRecoilState(sPullCameras);\n  let selectAll = useSetRecoilState(sSelectAll);\n  let setGridSize = useSetRecoilState(sGridSize);\n  let addCol = useSetRecoilState(sAddCol);\n  let remCol = useSetRecoilState(sRemCol);\n  let addRow = useSetRecoilState(sAddRow);\n  let remRow = useSetRecoilState(sRemRow);\n  let resetZoom = useSetRecoilState(sResetZoom);\n  let activeEscape = useSetRecoilState(sActiveEscape);\n  let addImage = useSetRecoilState(sAddImage);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let km_ref = useRef({});\n  let undo = useUndo();\n  let redo = useRedo();\n  let copy = useSetRecoilState(sCopy);\n  let paste = useSetRecoilState(sPaste);\n\n  const snapshot = useRecoilCallback();\n\n  let check = [\n    \"h\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"arrowleft\",\n    \"arrowright\",\n    \"arrowup\",\n    \"arrowdown\",\n  ];\n\n  let logState = useRecoilCallback(({ snapshot }) => () => {\n    let log = {};\n    log.cols = snapshot.getLoadable(aCols).contents;\n    log.rows = snapshot.getLoadable(aCols).contents;\n    log.cameras = snapshot.getLoadable(sAllCameras).contents;\n    console.log(JSON.stringify(log));\n  });\n\n  useEffect(() => {\n    let km = km_ref.current;\n    let scene = scene_ref.current;\n    let input = input_ref.current;\n    function pressed(press, e) {\n      // temp\n      if (km[\"1\"]) {\n        logState();\n      }\n\n      if (e.ctrlKey) {\n        if (check.includes(press)) {\n          e.preventDefault();\n          let scroll_diff = [0, 0];\n          if (press === \"h\" || press === \"arrowleft\") scroll_diff[0] -= 16;\n          if (press === \"j\" || press === \"arrowdown\") scroll_diff[1] += 16;\n          if (press === \"k\" || press === \"arrowup\") scroll_diff[1] -= 16;\n          if (press === \"l\" || press === \"arrowright\") scroll_diff[0] += 16;\n          window.scrollBy(...scroll_diff);\n        }\n        return;\n      }\n\n      if (check.includes(press)) {\n        e.preventDefault();\n      }\n\n      if (km.z) undo();\n      if (km.x) redo();\n\n      if (mode === \"normal\") {\n        if (km.h) moveActive([-1, 0]);\n        if (km.j) moveActive([0, 1]);\n        if (km.k) moveActive([0, -1]);\n        if (km.l) moveActive([1, 0]);\n        if (km.arrowleft) panCamera({ scene, diff: [-8, 0] });\n        if (km.arrowright) panCamera({ scene, diff: [8, 0] });\n        if (km.arrowup) panCamera({ scene, diff: [0, -8] });\n        if (km.arrowdown) panCamera({ scene, diff: [0, 8] });\n\n        if (press === \"r\") setMode(\"resize\");\n        if (press === \"a\") selectAll();\n        if (press === \"escape\") activeEscape();\n\n        if (km[\"-\"]) zoomCamera({ scene, sign: 1, mult: 1.125 });\n        if (km[\"+\"]) zoomCamera({ scene, sign: -1, mult: 1.125 });\n        if (km[\"=\"]) zoomCamera({ scene, sign: -1, mult: 1.125 });\n\n        if (km[\"s\"]) setZoomMode(\"canvas\");\n        if (km[\"i\"]) setZoomMode(\"individual\");\n        if (km[\"t\"]) setZoomMode(\"active\");\n\n        if (press === \"o\")\n          domLoadImage(scene, input, addImage, setImageMap.bind(null, {}));\n\n        if (km.c) copy();\n        if (km.v) paste();\n\n        if (km.e) shatterCamera({ scene });\n        if (km.m) mosaicCamera({ scene });\n        if (km.b) shakeCamera({ scene });\n        if (km.u) pushCameras({ scene });\n        if (km.n) pullCameras({ scene });\n        if (km.d) resetZoom();\n\n        // view\n        if (km.p) setShowPreview(!showPreview);\n        if (km.g) setShowGrid(!showGrid);\n        if (km.f) setShowCameras(!showCameras);\n\n        // save\n        if (km.w) scene.capture = true;\n\n        // undo redo\n        if (km.z) undo();\n        if (km.y) redo();\n\n        if (km[\"(\"]) remCol();\n        if (km[\")\"]) addCol();\n        if (km[\"[\"]) remRow();\n        if (km[\"]\"]) addRow();\n\n        if (press === \"x\") setMode(\"canvasResize\");\n        return;\n      } else if (mode === \"resize\") {\n        if (km.h) resizeActive([-1, 0]);\n        if (km.j) resizeActive([0, 1]);\n        if (km.k) resizeActive([0, -1]);\n        if (km.l) resizeActive([1, 0]);\n        if (km.arrowleft) resizeActive([-1, 0]);\n        if (km.arrowdown) resizeActive([0, 1]);\n        if (km.arrowup) resizeActive([0, -1]);\n        if (km.arrowright) resizeActive([1, 0]);\n\n        if (press === \"escape\") activeEscape();\n        if (press === \"a\") selectAll();\n        if (press === \"r\") setMode(\"normal\");\n        if (km.enter) setMode(\"normal\");\n        return;\n      } else if (mode === \"canvasResize\") {\n        if (km.h) setGridSize([-1, 0]);\n        if (km.j) setGridSize([0, 1]);\n        if (km.k) setGridSize([0, -1]);\n        if (km.l) setGridSize([1, 0]);\n        if (km.arrowleft) setGridSize([-1, 0]);\n        if (km.arrowdown) setGridSize([0, 1]);\n        if (km.arrowup) setGridSize([0, -1]);\n        if (km.arrowright) setGridSize([1, 0]);\n\n        if (press === \"x\") setMode(\"normal\");\n        if (km.enter) setMode(\"normal\");\n        return;\n      }\n    }\n\n    function downHandler(e) {\n      let press = e.key.toLowerCase();\n      km[press] = true;\n      pressed(press, e);\n    }\n\n    function upHandler(e) {\n      let press = e.key.toLowerCase();\n      km[press] = false;\n    }\n\n    window.addEventListener(\"keydown\", downHandler);\n    window.addEventListener(\"keyup\", upHandler);\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n      window.removeEventListener(\"keyup\", upHandler);\n    };\n  }, [mode, showGrid, showCameras, showPreview]);\n\n  return null;\n}\n\nexport default Keyboard;\n","/home/grant/dev/fracture/src/Mobile.js",["113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159"],"import React, { useEffect, useRef, useState } from \"react\";\nimport {\n  aSize,\n  aGridSize,\n  sViewports,\n  aCols,\n  aRows,\n  aMode,\n  aBarHeight,\n  aSidebar,\n  aCameras,\n  afCamera,\n  aImages,\n  sAddImage,\n  aImageMap,\n  sSetImageMap,\n  aSidebarWidth,\n  sMosaicCamera,\n  sAllCameras,\n  sMoveActiveSelector,\n  sResizeActiveSelector,\n  sPanCamera,\n  sZoomCamera,\n  sShatterCamera,\n  sSelectAll,\n  sShakeCamera,\n  sPushCameras,\n  sPullCameras,\n  sAddCol,\n  sRemCol,\n  sAddRow,\n  sRemRow,\n  sResetZoom,\n  sActiveEscape,\n  aShowCameras,\n  aShowGrid,\n  aZoomMode,\n  aShowPreview,\n  sCopy,\n  sPaste,\n  sGridSize,\n} from \"./State.js\";\nimport { domLoadImage } from \"./App\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport { useUndo, useRedo } from \"recoil-undo\";\nimport {\n  ToggleKeyButton,\n  KeyButton,\n  Spacer,\n  Info,\n  Tip,\n  HSpacer,\n} from \"./Sidebar\";\n\nfunction MobileBar({ scene_ref, input_ref }) {\n  let sidebarWidth = useRecoilValue(aSidebarWidth);\n  let [mode, setMode] = useRecoilState(aMode);\n  let [zoomMode, setZoomMode] = useRecoilState(aZoomMode);\n  let [showCameras, setShowCameras] = useRecoilState(aShowCameras);\n  let [showGrid, setShowGrid] = useRecoilState(aShowGrid);\n  let [showPreview, setShowPreview] = useRecoilState(aShowPreview);\n  let moveActive = useSetRecoilState(sMoveActiveSelector);\n  let resizeActive = useSetRecoilState(sResizeActiveSelector);\n  let zoomCamera = useSetRecoilState(sZoomCamera);\n  let panCamera = useSetRecoilState(sPanCamera);\n  let mosaicCamera = useSetRecoilState(sMosaicCamera);\n  let shatterCamera = useSetRecoilState(sShatterCamera);\n  let shakeCamera = useSetRecoilState(sShakeCamera);\n  let pushCameras = useSetRecoilState(sPushCameras);\n  let pullCameras = useSetRecoilState(sPullCameras);\n  let selectAll = useSetRecoilState(sSelectAll);\n  let copy = useSetRecoilState(sCopy);\n  let paste = useSetRecoilState(sPaste);\n  let addCol = useSetRecoilState(sAddCol);\n  let remCol = useSetRecoilState(sRemCol);\n  let addRow = useSetRecoilState(sAddRow);\n  let remRow = useSetRecoilState(sRemRow);\n  let resetZoom = useSetRecoilState(sResetZoom);\n  let activeEscape = useSetRecoilState(sActiveEscape);\n  let addImage = useSetRecoilState(sAddImage);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let setGridSize = useSetRecoilState(sGridSize);\n  let km_ref = useRef({});\n  let undo = useUndo();\n  let redo = useRedo();\n\n  let resize = mode === \"resize\";\n  let scene = scene_ref.current;\n  let input = input_ref.current;\n\n  return (\n    <div\n      style={{\n        paddingLeft: 8,\n        paddingRight: 8,\n      }}\n    >\n      <HSpacer />\n      <div\n        style={{\n          display: \"flex\",\n          justifyContent: \"space-between\",\n          alignItems: \"center\",\n        }}\n      >\n        <div>\n          <ToggleKeyButton\n            text=\"Resize selection\"\n            compare={resize}\n            click={setMode.bind(null, resize ? \"normal\" : \"resize\")}\n          />\n        </div>\n        <div>\n          Zoom:{\" \"}\n          <KeyButton\n            text=\"+\"\n            click={zoomCamera.bind(null, { scene, sign: -1 })}\n          />\n          <KeyButton\n            text=\"-\"\n            click={zoomCamera.bind(null, { scene, sign: 1 })}\n          />\n        </div>\n      </div>\n      <div>\n        <KeyButton text=\"Select all\" click={selectAll} />\n        <KeyButton text=\"Clear\" click={activeEscape} />\n      </div>\n      <HSpacer />\n      <Info>Zoom center</Info>\n      <div>\n        <ToggleKeyButton\n          text=\"Canvas\"\n          compare={zoomMode === \"canvas\"}\n          click={setZoomMode.bind(null, \"canvas\")}\n        />\n        <ToggleKeyButton\n          text=\"Individual\"\n          compare={zoomMode === \"individual\"}\n          click={setZoomMode.bind(null, \"individual\")}\n        />\n        <ToggleKeyButton\n          text=\"Active\"\n          compare={zoomMode === \"active\"}\n          click={setZoomMode.bind(null, \"active\")}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default MobileBar;\n","/home/grant/dev/fracture/src/constants.js",[],"/home/grant/dev/fracture/src/shaders.js",[],"/home/grant/dev/fracture/src/gl_utils.js",["160","161","162","163","164","165","166"],"import { base_zoom, start_zoom, zoom_scaler } from \"./constants.js\";\nimport {\n  perspective,\n  lookAt,\n  multiply,\n  invert,\n  multiplyPoint,\n  transformPoint,\n  normalize,\n} from \"./mat4.js\";\n\nexport function setViewports(scene, $render, cols, rows) {\n  let w = Math.floor($render.width / cols);\n  let h = Math.floor($render.height / rows);\n  scene.viewports = [];\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      scene.viewports.push([c * w, r * h, w, h]);\n    }\n  }\n}\n\nexport function initImageMap(scene, cols, rows) {\n  scene.viewport_image_map = [];\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      scene.viewport_image_map.push(null);\n    }\n  }\n}\n\nexport function initCameras(scene) {\n  scene.cameras = [];\n  scene.projection = [];\n  scene.inverse_projection = [];\n  scene.views = [];\n  scene.view_projections = [];\n  scene.inverse_view_projections = [];\n  for (let i = 0; i < scene.viewports.length; i++) {\n    scene.cameras.push([0, 0, start_zoom]);\n    scene.views.push([]);\n    scene.view_projections.push([]);\n    scene.inverse_view_projections.push([]);\n  }\n}\n\nexport function setProjectionMatrices(scene) {\n  if (scene.viewports.length > 0) {\n    let w = scene.viewports[0][2];\n    let h = scene.viewports[0][3];\n    perspective(scene.projection, Math.PI / 3, w / h, 0.01, 100);\n    invert(scene.inverse_projection, scene.projection);\n  }\n}\n\nfunction getLookAt(camera) {\n  return [camera[0], camera[1], 0];\n}\n\nexport function setViewMatrix(scene, i) {\n  let camera = scene.cameras[i];\n  if (scene.views[i]) {\n    lookAt(scene.views[i], camera, getLookAt(camera), [0, 1, 0]);\n    multiply(scene.view_projections[i], scene.projection, scene.views[i]);\n    invert(scene.inverse_view_projections[i], scene.view_projections[i]);\n  }\n}\n\nexport function setViewMatrices(scene) {\n  for (let i = 0; i < scene.cameras.length; i++) {\n    let camera = scene.cameras[i];\n    lookAt(scene.views[i], camera, getLookAt(camera), [0, 1, 0]);\n    multiply(scene.view_projections[i], scene.projection, scene.views[i]);\n    invert(scene.inverse_view_projections[i], scene.view_projections[i]);\n  }\n}\n\nexport function getProjectionZ(scene, world_z) {\n  let projected = multiplyPoint(scene.projection, [0, 0, world_z, 1]);\n  let ndz = projected[2] / projected[3];\n  return ndz;\n}\n\nexport function getWorldFromPx(scene, px, camera_dist) {\n  let z = getProjectionZ(scene, -camera_dist);\n  let raw = [(2 * px) / scene.viewports[0][2], 0, z, 1];\n  let point_world = multiplyPoint(scene.inverse_projection, raw);\n  return point_world[0] / point_world[3];\n}\n\nexport function mosaic(scene, indexes) {\n  let $render = scene.$render;\n  // need matrices to be initialized already\n  if (indexes === undefined) indexes = scene.group;\n  for (let i of indexes) {\n    let [vx, vy, vw, vh] = scene.viewports[i];\n    let camera = scene.cameras[i];\n    let midx = vx + vw / 2;\n    let midy = vy + vh / 2;\n    let difx = midx - $render.width / 2;\n    let dify = midy - $render.height / 2;\n    let w = getWorldFromPx(scene, difx, camera[2]);\n    let h = getWorldFromPx(scene, dify, camera[2]);\n    scene.cameras[i][0] = w;\n    scene.cameras[i][1] = h;\n  }\n}\n\nexport function panSetPixels(scene, x, y) {\n  let indexes = scene.active;\n  for (let index of indexes) {\n    let viewport = scene.viewports[index];\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, x * 8, camera[2]);\n    let ndy = getWorldFromPx(scene, y * 8, camera[2]);\n    scene.cameras[index][0] += ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function panViewports(scene, dx, dy) {\n  let indexes = scene.active;\n  for (let index of indexes) {\n    let viewport = scene.viewports[index];\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, dx, camera[2]);\n    let ndy = getWorldFromPx(scene, dy, camera[2]);\n    scene.cameras[index][0] -= ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function getClipsFromMouse(viewport, mouse_position) {\n  let ratio_x = (mouse_position[0] - viewport[0]) / viewport[2];\n  let ratio_y = (mouse_position[1] - viewport[1]) / viewport[3];\n  let clip_x = 2 * ratio_x - 1;\n  let clip_y = 2 * ratio_y - 1;\n  return [clip_x, clip_y];\n}\n\nexport function castRay(scene, index, mouse, world_z) {\n  let viewport = scene.viewports[index];\n  let ndz = getNormalizedZ(scene, index, world_z);\n  let clips = getClipsFromMouse(viewport, mouse);\n  let device_coordinates = [clips[0], clips[1], ndz, 1];\n  let point_world = multiplyPoint(\n    scene.inverse_view_projections[index],\n    device_coordinates\n  );\n  // divide by w at end\n  let world_points = [\n    point_world[0] / point_world[3],\n    point_world[1] / point_world[3],\n  ];\n  return world_points;\n}\n\nfunction zoomLimit(new_zoom) {\n  let max = 99;\n  let min = 0.01;\n  return Math.min(max, Math.max(min, new_zoom));\n}\n\nexport function zoomCenter(scene, sign) {\n  let indexes = scene.active;\n  for (let i of indexes) {\n    let zoom = scene.cameras[i][2];\n    let new_cam;\n    if (sign === 1) {\n      new_cam = scene.cameras[i][2] * zoom_scaler;\n    } else {\n      new_cam = scene.cameras[i][2] / zoom_scaler;\n    }\n    let new_zoom = zoomLimit(new_cam);\n    if (new_zoom > zoom || new_zoom < zoom) {\n      if (scene.zoom_mode === \"canvas\") {\n        let projected = castRay(\n          scene,\n          i,\n          [scene.width / 2, scene.height / 2],\n          new_zoom\n        );\n        scene.cameras[i] = [...projected, new_zoom];\n      } else if (scene.zoom_mode === \"active\") {\n        // TODO figure out if this is what you sant\n        let viewport = scene.viewports[scene.active];\n        let projected = castRay(\n          scene,\n          i,\n          [viewport[0] + viewport[2] / 2, viewport[1] + viewport[3] / 2],\n          new_zoom\n        );\n        scene.cameras[i] = [...projected, new_zoom];\n      } else if (scene.zoom_mode === \"every\") {\n        scene.cameras[i][2] = new_zoom;\n      }\n    }\n  }\n}\n\nexport function getNormalizedZ(scene, index, world_z) {\n  let projected = multiplyPoint(scene.view_projections[index], [\n    0,\n    0,\n    world_z,\n    1,\n  ]);\n  let ndz = projected[2] / projected[3];\n  return ndz;\n}\n\nexport function shake(scene) {\n  let indexes = scene.active;\n  for (let i = 0; i < indexes.length; i++) {\n    let index = indexes[i];\n    let camera = scene.cameras[index];\n    let nx = getWorldFromPx(scene, 16, camera[2]);\n    let dx = 1 - 2 * Math.random();\n    let dy = 1 - 2 * Math.random();\n    scene.cameras[index][0] += dx * nx;\n    scene.cameras[index][1] += dy * nx;\n  }\n}\n\nexport function viewportCenter(scene) {\n  let indexes = scene.active;\n  for (let index of indexes) {\n    scene.cameras[index][0] = 0;\n    scene.cameras[index][1] = 0;\n  }\n}\n\nexport function minMaxOrder(v1, v2) {\n  let min = Math.min(v1, v2);\n  let max = Math.max(v1, v2);\n  return [min, max];\n}\n\nexport function moveGroupWithFocus(group_selected, mactive, cols, rows) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let mx = mactive % cols;\n  let my = Math.floor(mactive / cols);\n  let start_col = x1;\n  let start_row = y1;\n  let end_col = x2;\n  let end_row = y2;\n  let w = x2 - x1;\n  let h = y2 - y1;\n  if (mx < x1) {\n    start_col = mx;\n    end_col = start_col + w;\n  } else if (mx > x2) {\n    end_col = mx;\n    start_col = end_col - w;\n  }\n  if (my < y1) {\n    start_row = my;\n    end_row = start_row + h;\n  } else if (my > y2) {\n    end_row = my;\n    start_row = end_row - h;\n  }\n  let g1 = start_row * cols + start_col;\n  let g2 = end_row * rows + end_col;\n  return [g1, g2];\n}\n\nexport function resizeGroupWithFocus(group_selected, mactive, cols, rows) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let mx = mactive % cols;\n  let my = Math.floor(mactive / cols);\n  let start_col = x1;\n  let start_row = y1;\n  let end_col = x2;\n  let end_row = y2;\n  let w = x2 - x1;\n  let h = y2 - y1;\n  if (mx < x1) {\n    start_col = mx;\n  } else if (mx > x2) {\n    end_col = mx;\n  }\n  if (my < y1) {\n    start_row = my;\n  } else if (my > y2) {\n    end_row = my;\n  }\n  let g1 = start_row * cols + start_col;\n  let g2 = end_row * cols + end_col;\n  return [g1, g2];\n}\n\nexport function resizeRelative(group_selected, cols, rows, dx, dy) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let end_col = Math.min(cols - 1, Math.max(x1, x2 + dx));\n  let end_row = Math.min(rows - 1, Math.max(y1, y2 + dy));\n  return end_row * cols + end_col;\n}\n\nexport function confineActive(group_selected, mactive, cols, rows) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let mx = mactive % cols;\n  let my = Math.floor(mactive / cols);\n  if (mx < x1) {\n    mx = x1;\n  } else if (mx > x2) {\n    mx = x2;\n  }\n  if (my < y1) {\n    my = y1;\n  } else if (my > y2) {\n    my = y2;\n  }\n  return my * cols + mx;\n}\n\nexport function getGroupIndexes(group, cols, rows) {\n  let x1 = group[0] % cols;\n  let y1 = Math.floor(group[0] / cols);\n  let x2 = group[1] % cols;\n  let y2 = Math.floor(group[1] / cols);\n  let indexes = [];\n  for (let r = 0; r < y2 - y1; r++) {\n    for (let c = 0; c < x2 - x1; c++) {\n      indexes.push(r * cols + c);\n    }\n  }\n  return indexes;\n}\n\nexport function push(scene) {\n  let group = scene.active;\n  let [x1, y1, x2, y2] = getVertices(scene.group, scene.cols, scene.rows);\n  let c1 = x1 + (x2 - x1 + 1) / 2;\n  let c2 = y1 + (y2 - y1 + 1) / 2;\n  for (let index of group) {\n    let c = (index % scene.cols) + 0.5;\n    let r = Math.floor(index / scene.cols) + 0.5;\n    let dx = 0;\n    let dy = 0;\n    if (c1 < c) {\n      dx = -1;\n    } else if (c1 > c) {\n      dx = 1;\n    }\n    if (c2 < r) {\n      dy = -1;\n    } else if (c2 > r) {\n      dy = 1;\n    }\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n    let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n    scene.cameras[index][0] += ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function pull(scene) {\n  let group = scene.active;\n  let [x1, y1, x2, y2] = getVertices(scene.group, scene.cols, scene.rows);\n  let c1 = x1 + (x2 - x1 + 1) / 2;\n  let c2 = y1 + (y2 - y1 + 1) / 2;\n  for (let index of group) {\n    let c = (index % scene.cols) + 0.5;\n    let r = Math.floor(index / scene.cols) + 0.5;\n    let dx = 0;\n    let dy = 0;\n    if (c1 < c) {\n      dx = 1;\n    } else if (c1 > c) {\n      dx = -1;\n    }\n    if (c2 < r) {\n      dy = 1;\n    } else if (c2 > r) {\n      dy = -1;\n    }\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n    let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n    scene.cameras[index][0] += ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function resetZoom(scene) {\n  let group = scene.active;\n  for (let index of group) {\n    scene.cameras[index][2] = start_zoom;\n  }\n}\n\nexport function copy(scene) {\n  let group = scene.active;\n  let copy_array = [];\n  for (let index of group) {\n    let camera = scene.cameras[index];\n    let image = scene.viewport_image_map[index];\n    let container = [camera, image];\n    copy_array.push(container);\n  }\n  scene.copy_buffer = copy_array;\n}\n\nexport function paste(scene) {\n  let buffer = scene.copy_buffer;\n  let group = scene.active;\n  if (buffer !== null) {\n    let i = 0;\n    for (let copy of buffer) {\n      let [camera, image] = JSON.parse(JSON.stringify(copy));\n      if (group[i] !== undefined) {\n        let index = group[i];\n        scene.cameras[index] = camera;\n        scene.viewport_image_map[index] = image;\n      }\n      i++;\n    }\n  }\n}\n\nexport function moveVertices(v, dx, dy) {\n  v[0] += dx;\n  v[1] += dy;\n  v[2] += dx;\n  v[3] += dy;\n  return v;\n}\n\nexport function getVertices(group, cols, rows) {\n  let x1 = group[0] % cols;\n  let y1 = Math.floor(group[0] / cols);\n  let x2 = group[1] % cols;\n  let y2 = Math.floor(group[1] / cols);\n  let gx1 = Math.min(x1, x2);\n  let gy1 = Math.min(y1, y2);\n  let gx2 = Math.max(x1, x2);\n  let gy2 = Math.max(y1, y2);\n  return [gx1, gy1, gx2, gy2];\n}\n\nexport function getIndexes(v, cols, rows) {\n  let [gx1, gy1, gx2, gy2] = v;\n  let i1 = gy1 * cols + gx1;\n  let i2 = gy2 * cols + gx2;\n  return [i1, i2];\n}\n\nexport function confineVertices(v, cols, rows) {\n  let [x1, y1, x2, y2] = v;\n  if (x1 < 0) {\n    let diff = -x1;\n    x1 += diff;\n    x2 += diff;\n  }\n  if (x2 > cols - 1) {\n    let diff = x2 - (cols - 1);\n    x1 -= diff;\n    x2 -= diff;\n  }\n  // too wide\n  if (x1 < 0) {\n    x1 = 0;\n  }\n  if (y1 < 0) {\n    let diff = -y1;\n    y1 += diff;\n    y2 += diff;\n  }\n  if (y2 > rows - 1) {\n    let diff = y2 - (rows - 1);\n    y1 -= diff;\n    y2 -= diff;\n  }\n  // too tall\n  if (y1 < 0) {\n    y1 = 0;\n  }\n  return [x1, y1, x2, y2];\n}\n\nexport function moveRelative(group, cols, rows, dx, dy) {\n  let v = moveVertices(getVertices(group, cols, rows), dx, dy);\n  v = confineVertices(v, cols, rows);\n  return getIndexes(v, cols, rows);\n}\n\nexport function confineToCanvas(group, cols, rows) {\n  let v = getVertices(group, cols, rows);\n  v = confineVertices(v, cols, rows);\n  return getIndexes(v, cols, rows);\n}\n\nexport function moveAbsolute(group, cols, rows, index) {\n  let [x1, y1, x2, y2] = getVertices(group, cols, rows);\n  let w = x2 - x1;\n  let h = y2 - y1;\n  let xoff1 = Math.floor(w / 2);\n  let xoff2 = w - xoff1;\n  let yoff1 = Math.floor(h / 2);\n  let yoff2 = h - yoff1;\n  let tar = getVertices([index, index], cols, rows);\n  let nx1 = tar[0] - xoff1;\n  let nx2 = tar[0] + xoff2;\n  let ny1 = tar[1] - yoff1;\n  let ny2 = tar[1] + yoff2;\n  let v = confineVertices([nx1, ny1, nx2, ny2], cols, rows);\n  return getIndexes(v, cols, rows);\n}\n\nexport function addSceneCol(scene, col) {\n  let $render = scene.$render;\n  let copied = [];\n  for (let r = 0; r < scene.rows; r++) {\n    let index = r * scene.cols + col;\n    let camera = scene.cameras[index];\n    let image = scene.viewport_image_map[index];\n    let container = [camera, image];\n    copied.push(container);\n  }\n  scene.cols += 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let r = 0; r < scene.rows; r++) {\n    let copy = JSON.parse(JSON.stringify(copied[r]));\n    let index = r * scene.cols + col;\n    scene.viewport_image_map.splice(index, 0, copy[1]);\n    scene.cameras.splice(index, 0, copy[0]);\n    scene.views.splice(index, 0, []);\n    scene.view_projections.splice(index, 0, []);\n    scene.inverse_view_projections.splice(index, 0, []);\n  }\n}\n\nexport function addSceneRow(scene, row) {\n  let $render = scene.$render;\n  let copied = [];\n  for (let c = 0; c < scene.cols; c++) {\n    let index = row * scene.cols + c;\n    let camera = scene.cameras[index];\n    let image = scene.viewport_image_map[index];\n    let container = [camera, image];\n    copied.push(container);\n  }\n  scene.rows += 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let c = 0; c < scene.cols; c++) {\n    let copy = JSON.parse(JSON.stringify(copied[c]));\n    let index = row * scene.cols + c;\n    scene.viewport_image_map.splice(index, 0, copy[1]);\n    scene.cameras.splice(index, 0, copy[0]);\n    scene.views.splice(index, 0, []);\n    scene.view_projections.splice(index, 0, []);\n    scene.inverse_view_projections.splice(index, 0, []);\n  }\n}\n\nexport function remSceneCol(scene, col) {\n  let $render = scene.$render;\n  scene.cols -= 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let r = 0; r < scene.rows; r++) {\n    let index = r * scene.cols + col;\n    scene.viewport_image_map.splice(index, 1);\n    scene.cameras.splice(index, 1);\n    scene.views.splice(index, 1);\n    scene.view_projections.splice(index, 1);\n    scene.inverse_view_projections.splice(index, 1);\n  }\n}\n\nexport function remSceneRow(scene, row) {\n  let $render = scene.$render;\n  scene.rows -= 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let c = 0; c < scene.cols; c++) {\n    // index is different bc it is chopping one each time\n    let index = row * scene.cols;\n    scene.viewport_image_map.splice(index, 1);\n    scene.cameras.splice(index, 1);\n    scene.views.splice(index, 1);\n    scene.view_projections.splice(index, 1);\n    scene.inverse_view_projections.splice(index, 1);\n  }\n}\n","/home/grant/dev/fracture/src/Sidebar.js",["167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183"],"import React, { useEffect, useRef, useState } from \"react\";\nimport {\n  aSize,\n  aGridSize,\n  sViewports,\n  aCols,\n  aRows,\n  aMode,\n  aBarHeight,\n  aSidebar,\n  aCameras,\n  afCamera,\n  aImages,\n  sAddImage,\n  aImageMap,\n  sSetImageMap,\n  aSidebarWidth,\n  sMosaicCamera,\n  sAllCameras,\n  sMoveActiveSelector,\n  sResizeActiveSelector,\n  sPanCamera,\n  sZoomCamera,\n  sShatterCamera,\n  sSelectAll,\n  sShakeCamera,\n  sPushCameras,\n  sPullCameras,\n  sAddCol,\n  sRemCol,\n  sAddRow,\n  sRemRow,\n  sResetZoom,\n  sActiveEscape,\n  aShowCameras,\n  aShowGrid,\n  aZoomMode,\n  aShowPreview,\n  sCopy,\n  sPaste,\n  sGridSize,\n} from \"./State.js\";\nimport { domLoadImage } from \"./App\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport { useUndo, useRedo } from \"recoil-undo\";\nimport Examples from \"./Examples\";\n\nfunction Heading(props) {\n  return (\n    <div className=\"heading\" style={{ marginBottom: 8 }}>\n      {props.children.toUpperCase()}\n    </div>\n  );\n}\n\nexport function Info(props) {\n  return <div style={{ marginBottom: 8 }}>{props.children}</div>;\n}\n\nexport function Tip(props) {\n  return <div style={{ marginBottom: 8, color: \"#aaa\" }}>{props.children}</div>;\n}\n\nexport function Spacer() {\n  return <div style={{ width: \"100%\", height: 8 }}></div>;\n}\n\nexport function HSpacer() {\n  return <div style={{ width: \"100%\", height: 4 }}></div>;\n}\n\nfunction Sidebar({ scene_ref, input_ref, mobile, bypass_ref }) {\n  let sidebarWidth = useRecoilValue(aSidebarWidth);\n  let [mode, setMode] = useRecoilState(aMode);\n  let [zoomMode, setZoomMode] = useRecoilState(aZoomMode);\n  let [showCameras, setShowCameras] = useRecoilState(aShowCameras);\n  let [showGrid, setShowGrid] = useRecoilState(aShowGrid);\n  let [showPreview, setShowPreview] = useRecoilState(aShowPreview);\n  let moveActive = useSetRecoilState(sMoveActiveSelector);\n  let resizeActive = useSetRecoilState(sResizeActiveSelector);\n  let zoomCamera = useSetRecoilState(sZoomCamera);\n  let panCamera = useSetRecoilState(sPanCamera);\n  let mosaicCamera = useSetRecoilState(sMosaicCamera);\n  let shatterCamera = useSetRecoilState(sShatterCamera);\n  let shakeCamera = useSetRecoilState(sShakeCamera);\n  let pushCameras = useSetRecoilState(sPushCameras);\n  let pullCameras = useSetRecoilState(sPullCameras);\n  let selectAll = useSetRecoilState(sSelectAll);\n  let copy = useSetRecoilState(sCopy);\n  let paste = useSetRecoilState(sPaste);\n  let addCol = useSetRecoilState(sAddCol);\n  let remCol = useSetRecoilState(sRemCol);\n  let addRow = useSetRecoilState(sAddRow);\n  let remRow = useSetRecoilState(sRemRow);\n  let resetZoom = useSetRecoilState(sResetZoom);\n  let activeEscape = useSetRecoilState(sActiveEscape);\n  let addImage = useSetRecoilState(sAddImage);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let setGridSize = useSetRecoilState(sGridSize);\n  let km_ref = useRef({});\n  let undo = useUndo();\n  let redo = useRedo();\n  let sidebarScrollRef = useRef(null);\n\n  let resize = mode === \"resize\";\n  let scene = scene_ref.current;\n  let input = input_ref.current;\n\n  let reg_style = {\n    position: \"fixed\",\n    right: 0,\n    height: \"100%\",\n    top: 0,\n    width: sidebarWidth,\n    overflow: \"auto\",\n    background: \"#222\",\n    userSelect: \"none\",\n  };\n  let mobile_style = {\n    position: \"fixed\",\n    left: 0,\n    bottom: 0,\n    height: 48 * 6,\n    overflow: \"auto\",\n    background: \"#222\",\n    userSelect: \"none\",\n  };\n\n  useEffect(() => {\n    if (sidebarScrollRef.current !== null) {\n      // put it here\n      sidebarScrollRef.current.scrollTo(0, 0);\n    }\n  }, [mode, sidebarScrollRef]);\n\n  return (\n    <div ref={sidebarScrollRef} style={mobile ? mobile_style : reg_style}>\n      <div\n        style={{\n          padding: 16,\n          userSelect: \"none\",\n        }}\n      >\n        {resize ? (\n          <div>\n            <Heading>Resize selection mode</Heading>\n            <div>\n              <ToggleKeyButton\n                text=\"Resize selection\"\n                keyname=\"r\"\n                compare={resize}\n                click={setMode.bind(null, \"normal\")}\n              />\n            </div>\n            <Info>Click and drag cells or use</Info>\n            <div>\n              <TwoKeyButton\n                text=\"narrower\"\n                keyname1=\"â†\"\n                keyname2=\"h\"\n                click={resizeActive.bind(null, [-1, 0])}\n              />\n            </div>\n            <div>\n              <TwoKeyButton\n                text=\"wider\"\n                keyname1=\"â†’\"\n                keyname2=\"l\"\n                click={resizeActive.bind(null, [-1, 0])}\n              />\n            </div>\n            <div>\n              <TwoKeyButton\n                text=\"shorter\"\n                keyname1=\"â†‘\"\n                keyname2=\"k\"\n                click={resizeActive.bind(null, [0, -1])}\n              />\n            </div>\n            <div>\n              <TwoKeyButton\n                text=\"taller\"\n                keyname1=\"â†“\"\n                keyname2=\"j\"\n                click={resizeActive.bind(null, [0, 1])}\n              />\n            </div>\n            <Info>Finish</Info>\n            <div>\n              <KeyButton\n                text=\"End resize\"\n                keyname=\"enter\"\n                click={setMode.bind(null, \"normal\")}\n              />\n            </div>\n            <Tip>\n              <div>TIP:</div>When resizing with the keyboard controls, the top\n              left corner of the selection is locked to its position.\n            </Tip>\n          </div>\n        ) : mode === \"canvasResize\" ? (\n          <div>\n            <Heading>Resize Canvas</Heading>\n            <ToggleKeyButton\n              text=\"Resize canvas\"\n              keyname=\"x\"\n              compare={mode === \"canvasResize\"}\n              click={setMode.bind(null, \"normal\")}\n            />\n            <div>\n              <TwoKeyButton\n                text=\"narrower\"\n                keyname1=\"â†\"\n                keyname2=\"h\"\n                click={setGridSize.bind(null, [-1, 0])}\n              />\n            </div>\n            <div>\n              <TwoKeyButton\n                text=\"wider\"\n                keyname1=\"â†’\"\n                keyname2=\"l\"\n                click={setGridSize.bind(null, [1, 0])}\n              />\n            </div>\n            <div>\n              <TwoKeyButton\n                text=\"shorter\"\n                keyname1=\"â†‘\"\n                keyname2=\"k\"\n                click={setGridSize.bind(null, [0, -1])}\n              />\n            </div>\n            <div>\n              <TwoKeyButton\n                text=\"taller\"\n                keyname1=\"â†“\"\n                keyname2=\"j\"\n                click={setGridSize.bind(null, [0, 1])}\n              />\n            </div>\n            <Info>Finish</Info>\n            <div>\n              <KeyButton\n                text=\"End resize\"\n                keyname=\"enter\"\n                click={setMode.bind(null, \"normal\")}\n              />\n            </div>\n            <HSpacer />\n            <Info>\n              Need to scroll the canvas? Hold Ctrl and click and drag, or use:\n            </Info>\n            <div>\n              <TwoKeyButton\n                text=\"\"\n                keyname1=\"Ctrl+â†\"\n                keyname2=\"Ctrl+h\"\n                click={window.scrollBy.bind(null, -16, 0)}\n              />\n              <TwoKeyButton\n                text=\"\"\n                keyname1=\"Ctrl+â†’\"\n                keyname2=\"Ctrl+l\"\n                click={window.scrollBy.bind(null, 16, 0)}\n              />\n              <TwoKeyButton\n                text=\"\"\n                keyname1=\"Ctrl+â†‘\"\n                keyname2=\"Ctrl+k\"\n                click={window.scrollBy.bind(null, 0, -16)}\n              />\n              <TwoKeyButton\n                text=\"\"\n                keyname1=\"Ctrl+â†“\"\n                keyname2=\"Ctrl+j\"\n                click={window.scrollBy.bind(null, 0, 16)}\n              />\n            </div>\n          </div>\n        ) : (\n          <div>\n            <Info>Shatter and recombine images using a grid of viewports</Info>\n            <HSpacer />\n            <Heading>Examples</Heading>\n            <Examples scene_ref={scene_ref} />\n            <HSpacer />\n            <Heading>Select</Heading>\n            <div>\n              <Info>Click a cell or move with</Info>\n              <KeyButton\n                text=\"â†\"\n                keyname=\"h\"\n                click={moveActive.bind(null, [-1, 0])}\n              />\n              <KeyButton\n                text=\"â†“\"\n                keyname=\"j\"\n                click={moveActive.bind(null, [0, 1])}\n              />\n              <KeyButton\n                text=\"â†‘\"\n                keyname=\"k\"\n                click={moveActive.bind(null, [0, -1])}\n              />\n              <KeyButton\n                text=\"â†’\"\n                keyname=\"l\"\n                click={moveActive.bind(null, [1, 0])}\n              />\n            </div>\n            <Info>Change selection size</Info>\n            <div>\n              <ToggleKeyButton\n                text=\"Resize selection\"\n                keyname=\"r\"\n                compare={resize}\n                click={setMode.bind(null, \"resize\")}\n              />\n              <div>\n                <KeyButton text=\"Select all\" keyname=\"a\" click={selectAll} />\n                <KeyButton text=\"Clear\" keyname=\"escape\" click={activeEscape} />\n              </div>\n            </div>\n            <HSpacer />\n            <Heading>Pan</Heading>\n            <Info>Click and drag or use</Info>\n            <div>\n              <KeyButton\n                text=\"\"\n                keyname=\"â†\"\n                click={panCamera.bind(null, { scene, diff: [1, 0] })}\n              />\n              <KeyButton\n                text=\"\"\n                keyname=\"â†“\"\n                click={panCamera.bind(null, { scene, diff: [0, 1] })}\n              />\n              <KeyButton\n                text=\"\"\n                keyname=\"â†‘\"\n                click={panCamera.bind(null, { scene, diff: [0, -1] })}\n              />\n              <KeyButton\n                text=\"\"\n                keyname=\"â†’\"\n                click={panCamera.bind(null, { scene, diff: [-1, 0] })}\n              />\n            </div>\n            <HSpacer />\n            <Heading>Zoom</Heading>\n            <Info>Scroll or use</Info>\n            <div>\n              <KeyButton\n                text=\"In\"\n                keyname=\"+\"\n                click={zoomCamera.bind(null, { scene, sign: -1, mult: 1.125 })}\n              />\n              <KeyButton\n                text=\"Out\"\n                keyname=\"-\"\n                click={zoomCamera.bind(null, { scene, sign: 1, mult: 1.125 })}\n              />\n            </div>\n            <Info>Zoom center</Info>\n            <div>\n              <ToggleKeyButton\n                text=\"Canvas\"\n                keyname=\"s\"\n                compare={zoomMode === \"canvas\"}\n                click={setZoomMode.bind(null, \"canvas\")}\n              />\n              <ToggleKeyButton\n                text=\"Individual\"\n                keyname=\"i\"\n                compare={zoomMode === \"individual\"}\n                click={setZoomMode.bind(null, \"individual\")}\n              />\n              <ToggleKeyButton\n                text=\"Active\"\n                keyname=\"t\"\n                compare={zoomMode === \"active\"}\n                click={setZoomMode.bind(null, \"active\")}\n              />\n            </div>\n            <HSpacer />\n            <Heading>Load image to selection</Heading>\n            <KeyButtonOnce\n              text=\"Load image\"\n              keyname=\"o\"\n              click={domLoadImage.bind(\n                null,\n                scene,\n                input,\n                addImage,\n                setImageMap.bind(null, {})\n              )}\n            />\n            <Info>\n              Or copy and paste an image\n              <br />\n              Or drag and drop an image file\n            </Info>\n            <HSpacer />\n            <Heading>Copy/Paste</Heading>\n            <HSpacer />\n            <KeyButton text=\"Copy\" keyname=\"c\" click={copy} />\n            <KeyButton text=\"Paste\" keyname=\"v\" click={paste} />\n            <Heading>More actions</Heading>\n            <KeyButton\n              text=\"Shatter\"\n              keyname=\"e\"\n              click={shatterCamera.bind(null, { scene })}\n            />\n            <KeyButton\n              text=\"Mosaic\"\n              keyname=\"m\"\n              click={mosaicCamera.bind(null, { scene })}\n            />\n            <KeyButton\n              text=\"Shake\"\n              keyname=\"b\"\n              click={shakeCamera.bind(null, { scene })}\n            />\n            <KeyButton\n              text=\"Push\"\n              keyname=\"u\"\n              click={pushCameras.bind(null, { scene })}\n            />\n            <KeyButton\n              text=\"Pull\"\n              keyname=\"n\"\n              click={pullCameras.bind(null, { scene })}\n            />\n            <KeyButton\n              text=\"Reset zoom\"\n              keyname=\"d\"\n              click={resetZoom.bind(null, scene)}\n            />\n            <HSpacer />\n            <Heading>View</Heading>\n            <ToggleKeyButton\n              text=\"Preview\"\n              keyname=\"p\"\n              compare={showPreview}\n              click={setShowPreview.bind(null, showPreview ? false : true)}\n            />\n            <ToggleKeyButton\n              text=\"Show grid\"\n              keyname=\"g\"\n              compare={showGrid}\n              disabled={showPreview ? true : false}\n              click={setShowGrid.bind(null, showGrid ? false : true)}\n            />\n            <ToggleKeyButton\n              text=\"Show camera info\"\n              keyname=\"f\"\n              disabled={showPreview ? true : false}\n              compare={showCameras}\n              click={setShowCameras.bind(null, showCameras ? false : true)}\n            />\n            <HSpacer />\n            <Heading>Save Image</Heading>\n            <HSpacer />\n            <KeyButton\n              text=\"Save image\"\n              keyname=\"w\"\n              click={() => {\n                scene.capture = true;\n              }}\n            />\n            <Heading>Undo/Redo</Heading>\n            <HSpacer />\n            <KeyButton text=\"Undo\" keyname=\"z\" click={undo} />\n            <KeyButton text=\"Redo\" keyname=\"y\" click={redo} />\n            <Heading>Change Grid</Heading>\n            <HSpacer />\n            <div>\n              {`Cols: `}\n              <KeyButton text=\"Remove\" keyname=\"(\" click={remCol} />\n              <KeyButton text=\"Add\" keyname=\")\" click={addCol} />\n            </div>\n            <div>\n              {`Rows: `}\n              <KeyButton text=\"Remove\" keyname=\"[\" click={remRow} />\n              <KeyButton text=\"Add\" keyname=\"]\" click={addRow} />\n            </div>\n            <Heading>Resize Canvas</Heading>\n            <ToggleKeyButton\n              text=\"Resize canvas\"\n              keyname=\"x\"\n              compare={mode === \"canvasResize\"}\n              click={setMode.bind(null, \"canvasResize\")}\n            />\n            <HSpacer />\n            <Tip>Need to scroll the canvas? Hold Ctrl and click and drag.</Tip>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default Sidebar;\n\nexport function KeyButton(props) {\n  let $button_ref = useRef(null);\n  let { text, click, keyname } = props;\n  window.intervalCheck = null;\n\n  useEffect(() => {\n    let $button = $button_ref.current;\n    let time;\n    function runInterval() {\n      window.intervalCheck = setInterval(click, 60);\n    }\n    function pointerDown(e) {\n      clearInterval(window.intervalCheck);\n      time = setTimeout(runInterval, 250);\n      click();\n      $button.setPointerCapture(e.pointerId);\n    }\n    function pointerUp(e) {\n      clearTimeout(time);\n      clearInterval(window.intervalCheck);\n      $button.releasePointerCapture(e.pointerId);\n    }\n    $button.addEventListener(\"pointerdown\", pointerDown);\n    $button.addEventListener(\"pointerup\", pointerUp);\n    return () => {\n      $button.removeEventListener(\"pointerdown\", pointerDown);\n      $button.removeEventListener(\"pointerup\", pointerUp);\n    };\n  }, []);\n\n  return (\n    <div ref={$button_ref} className=\"button\" role=\"button\">\n      {text !== \"\" ? text + \" \" : \"\"}\n      {keyname ? <span className=\"keyname\">{keyname}</span> : \"\"}\n    </div>\n  );\n}\n\nexport function KeyButtonOnce(props) {\n  let $button_ref = useRef(null);\n  let { text, click, keyname } = props;\n\n  return (\n    <div ref={$button_ref} className=\"button\" role=\"button\" onClick={click}>\n      {text !== \"\" ? text + \" \" : \"\"}\n      <span className=\"keyname\">{keyname}</span>\n    </div>\n  );\n}\n\nexport function TwoKeyButton(props) {\n  let $button_ref = useRef(null);\n  let { text, click, keyname1, keyname2 } = props;\n\n  useEffect(() => {\n    let $button = $button_ref.current;\n    let time;\n    let interval;\n    function runInterval() {\n      interval = setInterval(click, 60);\n    }\n    function pointerDown(e) {\n      $button.setPointerCapture(e.pointerId);\n      time = setTimeout(runInterval, 250);\n      click();\n    }\n    function pointerUp(e) {\n      $button.releasePointerCapture(e.pointerId);\n      clearTimeout(time);\n      clearInterval(interval);\n    }\n    $button.addEventListener(\"pointerdown\", pointerDown);\n    $button.addEventListener(\"pointerup\", pointerUp);\n    return () => {\n      $button.removeEventListener(\"pointerdown\", pointerDown);\n      $button.removeEventListener(\"pointerup\", pointerUp);\n    };\n  }, []);\n\n  return (\n    <div ref={$button_ref} className=\"button\" role=\"button\">\n      {text !== \"\" ? text + \" \" : \"\"}\n      <span className=\"keyname\">{keyname1}</span>{\" \"}\n      <span className=\"keytip\">or</span>{\" \"}\n      <span className=\"keyname\">{keyname2}</span>\n    </div>\n  );\n}\n\nexport function ToggleKeyButton(props) {\n  let $button_ref = useRef(null);\n  let { text, click, keyname, compare, disabled } = props;\n\n  // toggle requires click every time TODO: switch to mousedown for consistent response?\n  return (\n    <div\n      ref={$button_ref}\n      className={`button toggle ${compare ? \"active\" : \"\"} ${\n        disabled ? \"disabled\" : \"\"\n      }`}\n      role=\"button\"\n      onClick={click}\n    >\n      {text !== \"\" ? text + \" \" : \"\"}\n      {keyname ? <span className=\"keyname\">{keyname}</span> : null}\n    </div>\n  );\n}\n","/home/grant/dev/fracture/src/Gl.js",["184"],"import REGL from \"regl\";\n\nexport function draw(regl) {\n  return regl({\n    frag: `\n    precision mediump float;\n    uniform vec4 color;\n    void main() {\n      gl_FragColor = color;\n    }`,\n\n    vert: `\n    precision mediump float;\n    attribute vec2 position;\n    uniform float angle;\n    void main() {\n      gl_Position = vec4(\n        cos(angle) * position.x + sin(angle) * position.y,\n        -sin(angle) * position.x + cos(angle) * position.y, 0, 1);\n    }`,\n\n    attributes: {\n      position: [-1, 0, 0, -1, 1, 1],\n    },\n\n    uniforms: {\n      color: regl.prop(\"color\"),\n      angle: ({ tick }) => 0.01 * tick,\n    },\n\n    depth: {\n      enable: false,\n    },\n\n    count: 3,\n  });\n}\n","/home/grant/dev/fracture/src/mat4.js",[],"/home/grant/dev/fracture/src/Examples.js",["185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209"],"import React, { Fragment, useEffect, useRef, useState } from \"react\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport {\n  aActive,\n  aSize,\n  aGridSize,\n  sViewports,\n  aCols,\n  aRows,\n  aMode,\n  aBarHeight,\n  aSidebarWidth,\n  aCameras,\n  sShakeCamera,\n  afCamera,\n  aImages,\n  sShatterCamera,\n  sActiveSelector,\n  sAddImage,\n  sResetZoom,\n  aImageMap,\n  sSetImageMap,\n  sMosaicCamera,\n  sAllCameras,\n  sZoomCamera,\n  aShowCameras,\n  aShowGrid,\n  aShowPreview,\n  sAddCol,\n  sRemCol,\n  sAddRow,\n  sRemRow,\n  sCopy,\n  sPaste,\n} from \"./State.js\";\nimport { KeyButton } from \"./Sidebar\";\nimport { loadImage } from \"./App\";\n\nfunction Examples({ scene_ref }) {\n  let scene = scene_ref.current;\n  let addImage = useSetRecoilState(sAddImage);\n  let zoomCamera = useSetRecoilState(sZoomCamera);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let shatterCamera = useSetRecoilState(sShatterCamera);\n  let mosaicCamera = useSetRecoilState(sMosaicCamera);\n  let shakeCamera = useSetRecoilState(sShakeCamera);\n  let resetZoom = useSetRecoilState(sResetZoom);\n  let setActive = useSetRecoilState(sActiveSelector);\n  let addCol = useSetRecoilState(sAddCol);\n  let remCol = useSetRecoilState(sRemCol);\n  let addRow = useSetRecoilState(sAddRow);\n  let remRow = useSetRecoilState(sRemRow);\n  let copy = useSetRecoilState(sCopy);\n  let paste = useSetRecoilState(sPaste);\n\n  function loadFLW() {\n    let new_cols = 4;\n    let new_rows = 4;\n    let col_diff = new_cols - scene.cols;\n    let row_diff = new_rows - scene.rows;\n    if (col_diff > 0) {\n      for (let i = 0; i < col_diff; i++) {\n        addCol();\n      }\n    }\n    if (col_diff < 0) {\n      for (let i = 0; i < Math.abs(col_diff); i++) {\n        remCol();\n      }\n    }\n    if (row_diff > 0) {\n      for (let i = 0; i < row_diff; i++) {\n        addRow();\n      }\n    }\n    if (row_diff < 0) {\n      for (let i = 0; i < Math.abs(row_diff); i++) {\n        remRow();\n      }\n    }\n    loadImage(\n      scene,\n      process.env.PUBLIC_URL + \"/images/flw.jpg\",\n      addImage,\n      setImageMap.bind(null, { active: [0, 0, new_cols, new_rows] }),\n      () => {\n        setActive([0, 0, new_cols, new_rows]);\n        resetZoom();\n        zoomCamera({ scene, sign: 1, mult: 1.5 });\n        setActive([0, 0, new_cols / 2, new_rows]);\n        mosaicCamera({ scene });\n        setActive([2, 0, new_cols / 2, new_rows]);\n        shatterCamera({ scene });\n      }\n    );\n  }\n\n  function loadAnimals() {\n    let new_cols = 4;\n    let new_rows = 4;\n    let col_diff = new_cols - scene.cols;\n    let row_diff = new_rows - scene.rows;\n    if (col_diff > 0) {\n      for (let i = 0; i < col_diff; i++) {\n        addCol();\n      }\n    }\n    if (col_diff < 0) {\n      for (let i = 0; i < Math.abs(col_diff); i++) {\n        remCol();\n      }\n    }\n    if (row_diff > 0) {\n      for (let i = 0; i < row_diff; i++) {\n        addRow();\n      }\n    }\n    if (row_diff < 0) {\n      for (let i = 0; i < Math.abs(row_diff); i++) {\n        remRow();\n      }\n    }\n    loadImage(\n      scene,\n      process.env.PUBLIC_URL + \"/images/dog.jpg\",\n      addImage,\n      setImageMap.bind(null, { active: [0, 0, 2, 2] }),\n      () => {\n        setActive([0, 0, 2, 2]);\n        resetZoom();\n        mosaicCamera({ scene });\n      }\n    );\n    loadImage(\n      scene,\n      process.env.PUBLIC_URL + \"/images/panda.jpg\",\n      addImage,\n      setImageMap.bind(null, { active: [2, 0, 2, 4] }),\n      () => {\n        setActive([2, 0, 2, 4]);\n        resetZoom();\n        mosaicCamera({ scene });\n      }\n    );\n    loadImage(\n      scene,\n      process.env.PUBLIC_URL + \"/images/frog.jpg\",\n      addImage,\n      setImageMap.bind(null, { active: [0, 2, 2, 2] }),\n      () => {\n        setActive([0, 2, 2, 2]);\n        resetZoom();\n        mosaicCamera({ scene });\n      }\n    );\n  }\n\n  function loadTile() {\n    let new_cols = 5;\n    let new_rows = 3;\n    let col_diff = new_cols - scene.cols;\n    let row_diff = new_rows - scene.rows;\n    if (col_diff > 0) {\n      for (let i = 0; i < col_diff; i++) {\n        addCol();\n      }\n    }\n    if (col_diff < 0) {\n      for (let i = 0; i < Math.abs(col_diff); i++) {\n        remCol();\n      }\n    }\n    if (row_diff > 0) {\n      for (let i = 0; i < row_diff; i++) {\n        addRow();\n      }\n    }\n    if (row_diff < 0) {\n      for (let i = 0; i < Math.abs(row_diff); i++) {\n        remRow();\n      }\n    }\n    loadImage(\n      scene,\n      process.env.PUBLIC_URL + \"/images/iron.jpg\",\n      addImage,\n      setImageMap.bind(null, { active: [4, 0, 1, 1] }),\n      () => {\n        setActive([4, 0, 1, 1]);\n        resetZoom();\n        zoomCamera({ scene, sign: 1, mult: 2 });\n        shatterCamera({ scene });\n        copy();\n        setActive([0, 0, 1, 1]);\n        paste();\n        setActive([2, 0, 1, 1]);\n        paste();\n        setActive([1, 1, 1, 1]);\n        paste();\n        setActive([3, 1, 1, 1]);\n        paste();\n        setActive([2, 2, 1, 1]);\n        paste();\n        setActive([0, 2, 1, 1]);\n        paste();\n        setActive([2, 2, 1, 1]);\n        paste();\n        setActive([4, 2, 1, 1]);\n        paste();\n      }\n    );\n    loadImage(\n      scene,\n      process.env.PUBLIC_URL + \"/images/smithsonite.jpg\",\n      addImage,\n      setImageMap.bind(null, { active: [4, 1, 1, 1] }),\n      () => {\n        setActive([4, 1, 1, 1]);\n        resetZoom();\n        zoomCamera({ scene, sign: 1, mult: 2 });\n        shatterCamera({ scene });\n        copy();\n        setActive([1, 0, 1, 1]);\n        paste();\n        setActive([3, 0, 1, 1]);\n        paste();\n        setActive([0, 1, 1, 1]);\n        paste();\n        setActive([2, 1, 1, 1]);\n        paste();\n        setActive([1, 2, 1, 1]);\n        paste();\n        setActive([3, 2, 1, 1]);\n        paste();\n      }\n    );\n  }\n\n  return (\n    <div>\n      <KeyButton text=\"Animals\" click={loadAnimals} />\n      <KeyButton text=\"Wright\" click={loadFLW} />\n      <KeyButton text=\"Rocks\" click={loadTile} />\n    </div>\n  );\n}\n\nexport default Examples;\n",{"ruleId":"210","replacedBy":"211"},{"ruleId":"212","replacedBy":"213"},{"ruleId":"214","severity":1,"message":"215","line":38,"column":3,"nodeType":"216","messageId":"217","endLine":38,"endColumn":10},{"ruleId":"214","severity":1,"message":"218","line":39,"column":3,"nodeType":"216","messageId":"217","endLine":39,"endColumn":10},{"ruleId":"214","severity":1,"message":"219","line":44,"column":8,"nodeType":"216","messageId":"217","endLine":44,"endColumn":17},{"ruleId":"214","severity":1,"message":"220","line":108,"column":11,"nodeType":"216","messageId":"217","endLine":108,"endColumn":12},{"ruleId":"221","severity":1,"message":"222","line":164,"column":6,"nodeType":"223","endLine":164,"endColumn":28,"suggestions":"224"},{"ruleId":"214","severity":1,"message":"225","line":272,"column":7,"nodeType":"216","messageId":"217","endLine":272,"endColumn":18},{"ruleId":"214","severity":1,"message":"226","line":427,"column":7,"nodeType":"216","messageId":"217","endLine":427,"endColumn":13},{"ruleId":"214","severity":1,"message":"227","line":438,"column":11,"nodeType":"216","messageId":"217","endLine":438,"endColumn":31},{"ruleId":"221","severity":1,"message":"228","line":530,"column":6,"nodeType":"223","endLine":530,"endColumn":24,"suggestions":"229"},{"ruleId":"221","severity":1,"message":"230","line":537,"column":6,"nodeType":"223","endLine":537,"endColumn":24,"suggestions":"231"},{"ruleId":"221","severity":1,"message":"232","line":543,"column":6,"nodeType":"223","endLine":543,"endColumn":56,"suggestions":"233"},{"ruleId":"214","severity":1,"message":"234","line":616,"column":10,"nodeType":"216","messageId":"217","endLine":616,"endColumn":20},{"ruleId":"214","severity":1,"message":"235","line":1,"column":8,"nodeType":"216","messageId":"217","endLine":1,"endColumn":13},{"ruleId":"214","severity":1,"message":"236","line":4,"column":21,"nodeType":"216","messageId":"217","endLine":4,"endColumn":32},{"ruleId":"214","severity":1,"message":"237","line":194,"column":16,"nodeType":"216","messageId":"217","endLine":194,"endColumn":17},{"ruleId":"214","severity":1,"message":"220","line":194,"column":19,"nodeType":"216","messageId":"217","endLine":194,"endColumn":20},{"ruleId":"214","severity":1,"message":"238","line":380,"column":9,"nodeType":"216","messageId":"217","endLine":380,"endColumn":13},{"ruleId":"214","severity":1,"message":"239","line":515,"column":10,"nodeType":"216","messageId":"217","endLine":515,"endColumn":11},{"ruleId":"214","severity":1,"message":"240","line":515,"column":13,"nodeType":"216","messageId":"217","endLine":515,"endColumn":15},{"ruleId":"214","severity":1,"message":"235","line":1,"column":8,"nodeType":"216","messageId":"217","endLine":1,"endColumn":13},{"ruleId":"214","severity":1,"message":"241","line":1,"column":17,"nodeType":"216","messageId":"217","endLine":1,"endColumn":25},{"ruleId":"214","severity":1,"message":"242","line":3,"column":3,"nodeType":"216","messageId":"217","endLine":3,"endColumn":13},{"ruleId":"214","severity":1,"message":"243","line":4,"column":3,"nodeType":"216","messageId":"217","endLine":4,"endColumn":17},{"ruleId":"214","severity":1,"message":"244","line":8,"column":10,"nodeType":"216","messageId":"217","endLine":8,"endColumn":14},{"ruleId":"214","severity":1,"message":"245","line":23,"column":10,"nodeType":"216","messageId":"217","endLine":23,"endColumn":18},{"ruleId":"214","severity":1,"message":"246","line":39,"column":10,"nodeType":"216","messageId":"217","endLine":39,"endColumn":18},{"ruleId":"214","severity":1,"message":"247","line":71,"column":9,"nodeType":"216","messageId":"217","endLine":71,"endColumn":19},{"ruleId":"214","severity":1,"message":"248","line":71,"column":21,"nodeType":"216","messageId":"217","endLine":71,"endColumn":29},{"ruleId":"214","severity":1,"message":"249","line":90,"column":9,"nodeType":"216","messageId":"217","endLine":90,"endColumn":15},{"ruleId":"214","severity":1,"message":"250","line":141,"column":14,"nodeType":"216","messageId":"217","endLine":141,"endColumn":16},{"ruleId":"214","severity":1,"message":"251","line":141,"column":18,"nodeType":"216","messageId":"217","endLine":141,"endColumn":20},{"ruleId":"214","severity":1,"message":"252","line":141,"column":22,"nodeType":"216","messageId":"217","endLine":141,"endColumn":24},{"ruleId":"214","severity":1,"message":"253","line":141,"column":26,"nodeType":"216","messageId":"217","endLine":141,"endColumn":28},{"ruleId":"214","severity":1,"message":"254","line":189,"column":11,"nodeType":"216","messageId":"217","endLine":189,"endColumn":19},{"ruleId":"221","severity":1,"message":"255","line":230,"column":6,"nodeType":"223","endLine":230,"endColumn":49,"suggestions":"256"},{"ruleId":"214","severity":1,"message":"241","line":1,"column":29,"nodeType":"216","messageId":"217","endLine":1,"endColumn":37},{"ruleId":"214","severity":1,"message":"242","line":3,"column":3,"nodeType":"216","messageId":"217","endLine":3,"endColumn":13},{"ruleId":"214","severity":1,"message":"257","line":5,"column":3,"nodeType":"216","messageId":"217","endLine":5,"endColumn":17},{"ruleId":"214","severity":1,"message":"258","line":7,"column":3,"nodeType":"216","messageId":"217","endLine":7,"endColumn":20},{"ruleId":"214","severity":1,"message":"259","line":39,"column":3,"nodeType":"216","messageId":"217","endLine":39,"endColumn":8},{"ruleId":"214","severity":1,"message":"260","line":48,"column":8,"nodeType":"216","messageId":"217","endLine":48,"endColumn":16},{"ruleId":"214","severity":1,"message":"261","line":75,"column":9,"nodeType":"216","messageId":"217","endLine":75,"endColumn":17},{"ruleId":"221","severity":1,"message":"262","line":228,"column":6,"nodeType":"223","endLine":228,"endColumn":48,"suggestions":"263"},{"ruleId":"214","severity":1,"message":"264","line":1,"column":17,"nodeType":"216","messageId":"217","endLine":1,"endColumn":26},{"ruleId":"214","severity":1,"message":"241","line":1,"column":36,"nodeType":"216","messageId":"217","endLine":1,"endColumn":44},{"ruleId":"214","severity":1,"message":"265","line":3,"column":3,"nodeType":"216","messageId":"217","endLine":3,"endColumn":8},{"ruleId":"214","severity":1,"message":"266","line":4,"column":3,"nodeType":"216","messageId":"217","endLine":4,"endColumn":12},{"ruleId":"214","severity":1,"message":"267","line":5,"column":3,"nodeType":"216","messageId":"217","endLine":5,"endColumn":13},{"ruleId":"214","severity":1,"message":"268","line":6,"column":3,"nodeType":"216","messageId":"217","endLine":6,"endColumn":8},{"ruleId":"214","severity":1,"message":"259","line":7,"column":3,"nodeType":"216","messageId":"217","endLine":7,"endColumn":8},{"ruleId":"214","severity":1,"message":"269","line":9,"column":3,"nodeType":"216","messageId":"217","endLine":9,"endColumn":13},{"ruleId":"214","severity":1,"message":"270","line":10,"column":3,"nodeType":"216","messageId":"217","endLine":10,"endColumn":11},{"ruleId":"214","severity":1,"message":"271","line":11,"column":3,"nodeType":"216","messageId":"217","endLine":11,"endColumn":11},{"ruleId":"214","severity":1,"message":"272","line":12,"column":3,"nodeType":"216","messageId":"217","endLine":12,"endColumn":11},{"ruleId":"214","severity":1,"message":"273","line":13,"column":3,"nodeType":"216","messageId":"217","endLine":13,"endColumn":10},{"ruleId":"214","severity":1,"message":"274","line":15,"column":3,"nodeType":"216","messageId":"217","endLine":15,"endColumn":12},{"ruleId":"214","severity":1,"message":"275","line":19,"column":3,"nodeType":"216","messageId":"217","endLine":19,"endColumn":14},{"ruleId":"214","severity":1,"message":"276","line":43,"column":10,"nodeType":"216","messageId":"217","endLine":43,"endColumn":22},{"ruleId":"214","severity":1,"message":"242","line":45,"column":3,"nodeType":"216","messageId":"217","endLine":45,"endColumn":13},{"ruleId":"214","severity":1,"message":"277","line":54,"column":3,"nodeType":"216","messageId":"217","endLine":54,"endColumn":9},{"ruleId":"214","severity":1,"message":"278","line":56,"column":3,"nodeType":"216","messageId":"217","endLine":56,"endColumn":6},{"ruleId":"214","severity":1,"message":"279","line":61,"column":7,"nodeType":"216","messageId":"217","endLine":61,"endColumn":19},{"ruleId":"214","severity":1,"message":"280","line":64,"column":8,"nodeType":"216","messageId":"217","endLine":64,"endColumn":19},{"ruleId":"214","severity":1,"message":"281","line":64,"column":21,"nodeType":"216","messageId":"217","endLine":64,"endColumn":35},{"ruleId":"214","severity":1,"message":"282","line":65,"column":8,"nodeType":"216","messageId":"217","endLine":65,"endColumn":16},{"ruleId":"214","severity":1,"message":"283","line":65,"column":18,"nodeType":"216","messageId":"217","endLine":65,"endColumn":29},{"ruleId":"214","severity":1,"message":"225","line":66,"column":8,"nodeType":"216","messageId":"217","endLine":66,"endColumn":19},{"ruleId":"214","severity":1,"message":"284","line":66,"column":21,"nodeType":"216","messageId":"217","endLine":66,"endColumn":35},{"ruleId":"214","severity":1,"message":"285","line":67,"column":7,"nodeType":"216","messageId":"217","endLine":67,"endColumn":17},{"ruleId":"214","severity":1,"message":"286","line":68,"column":7,"nodeType":"216","messageId":"217","endLine":68,"endColumn":19},{"ruleId":"214","severity":1,"message":"287","line":70,"column":7,"nodeType":"216","messageId":"217","endLine":70,"endColumn":16},{"ruleId":"214","severity":1,"message":"288","line":71,"column":7,"nodeType":"216","messageId":"217","endLine":71,"endColumn":19},{"ruleId":"214","severity":1,"message":"289","line":72,"column":7,"nodeType":"216","messageId":"217","endLine":72,"endColumn":20},{"ruleId":"214","severity":1,"message":"290","line":73,"column":7,"nodeType":"216","messageId":"217","endLine":73,"endColumn":18},{"ruleId":"214","severity":1,"message":"291","line":74,"column":7,"nodeType":"216","messageId":"217","endLine":74,"endColumn":18},{"ruleId":"214","severity":1,"message":"292","line":75,"column":7,"nodeType":"216","messageId":"217","endLine":75,"endColumn":18},{"ruleId":"214","severity":1,"message":"293","line":77,"column":7,"nodeType":"216","messageId":"217","endLine":77,"endColumn":11},{"ruleId":"214","severity":1,"message":"294","line":78,"column":7,"nodeType":"216","messageId":"217","endLine":78,"endColumn":12},{"ruleId":"214","severity":1,"message":"295","line":79,"column":7,"nodeType":"216","messageId":"217","endLine":79,"endColumn":13},{"ruleId":"214","severity":1,"message":"296","line":80,"column":7,"nodeType":"216","messageId":"217","endLine":80,"endColumn":13},{"ruleId":"214","severity":1,"message":"297","line":81,"column":7,"nodeType":"216","messageId":"217","endLine":81,"endColumn":13},{"ruleId":"214","severity":1,"message":"298","line":82,"column":7,"nodeType":"216","messageId":"217","endLine":82,"endColumn":13},{"ruleId":"214","severity":1,"message":"299","line":83,"column":7,"nodeType":"216","messageId":"217","endLine":83,"endColumn":16},{"ruleId":"214","severity":1,"message":"300","line":85,"column":7,"nodeType":"216","messageId":"217","endLine":85,"endColumn":15},{"ruleId":"214","severity":1,"message":"301","line":86,"column":7,"nodeType":"216","messageId":"217","endLine":86,"endColumn":18},{"ruleId":"214","severity":1,"message":"302","line":87,"column":7,"nodeType":"216","messageId":"217","endLine":87,"endColumn":18},{"ruleId":"214","severity":1,"message":"303","line":88,"column":7,"nodeType":"216","messageId":"217","endLine":88,"endColumn":13},{"ruleId":"214","severity":1,"message":"304","line":89,"column":7,"nodeType":"216","messageId":"217","endLine":89,"endColumn":11},{"ruleId":"214","severity":1,"message":"305","line":90,"column":7,"nodeType":"216","messageId":"217","endLine":90,"endColumn":11},{"ruleId":"214","severity":1,"message":"306","line":94,"column":7,"nodeType":"216","messageId":"217","endLine":94,"endColumn":12},{"ruleId":"214","severity":1,"message":"307","line":1,"column":10,"nodeType":"216","messageId":"217","endLine":1,"endColumn":19},{"ruleId":"214","severity":1,"message":"308","line":8,"column":3,"nodeType":"216","messageId":"217","endLine":8,"endColumn":17},{"ruleId":"214","severity":1,"message":"309","line":9,"column":3,"nodeType":"216","messageId":"217","endLine":9,"endColumn":12},{"ruleId":"214","severity":1,"message":"310","line":112,"column":9,"nodeType":"216","messageId":"217","endLine":112,"endColumn":17},{"ruleId":"214","severity":1,"message":"310","line":124,"column":9,"nodeType":"216","messageId":"217","endLine":124,"endColumn":17},{"ruleId":"214","severity":1,"message":"237","line":282,"column":7,"nodeType":"216","messageId":"217","endLine":282,"endColumn":8},{"ruleId":"214","severity":1,"message":"220","line":283,"column":7,"nodeType":"216","messageId":"217","endLine":283,"endColumn":8},{"ruleId":"214","severity":1,"message":"241","line":1,"column":36,"nodeType":"216","messageId":"217","endLine":1,"endColumn":44},{"ruleId":"214","severity":1,"message":"265","line":3,"column":3,"nodeType":"216","messageId":"217","endLine":3,"endColumn":8},{"ruleId":"214","severity":1,"message":"266","line":4,"column":3,"nodeType":"216","messageId":"217","endLine":4,"endColumn":12},{"ruleId":"214","severity":1,"message":"267","line":5,"column":3,"nodeType":"216","messageId":"217","endLine":5,"endColumn":13},{"ruleId":"214","severity":1,"message":"268","line":6,"column":3,"nodeType":"216","messageId":"217","endLine":6,"endColumn":8},{"ruleId":"214","severity":1,"message":"259","line":7,"column":3,"nodeType":"216","messageId":"217","endLine":7,"endColumn":8},{"ruleId":"214","severity":1,"message":"269","line":9,"column":3,"nodeType":"216","messageId":"217","endLine":9,"endColumn":13},{"ruleId":"214","severity":1,"message":"270","line":10,"column":3,"nodeType":"216","messageId":"217","endLine":10,"endColumn":11},{"ruleId":"214","severity":1,"message":"271","line":11,"column":3,"nodeType":"216","messageId":"217","endLine":11,"endColumn":11},{"ruleId":"214","severity":1,"message":"272","line":12,"column":3,"nodeType":"216","messageId":"217","endLine":12,"endColumn":11},{"ruleId":"214","severity":1,"message":"273","line":13,"column":3,"nodeType":"216","messageId":"217","endLine":13,"endColumn":10},{"ruleId":"214","severity":1,"message":"274","line":15,"column":3,"nodeType":"216","messageId":"217","endLine":15,"endColumn":12},{"ruleId":"214","severity":1,"message":"275","line":19,"column":3,"nodeType":"216","messageId":"217","endLine":19,"endColumn":14},{"ruleId":"214","severity":1,"message":"242","line":45,"column":3,"nodeType":"216","messageId":"217","endLine":45,"endColumn":13},{"ruleId":"214","severity":1,"message":"303","line":105,"column":7,"nodeType":"216","messageId":"217","endLine":105,"endColumn":13},{"ruleId":"221","severity":1,"message":"311","line":539,"column":6,"nodeType":"223","endLine":539,"endColumn":8,"suggestions":"312"},{"ruleId":"221","severity":1,"message":"311","line":588,"column":6,"nodeType":"223","endLine":588,"endColumn":8,"suggestions":"313"},{"ruleId":"214","severity":1,"message":"314","line":1,"column":8,"nodeType":"216","messageId":"217","endLine":1,"endColumn":12},{"ruleId":"214","severity":1,"message":"315","line":1,"column":17,"nodeType":"216","messageId":"217","endLine":1,"endColumn":25},{"ruleId":"214","severity":1,"message":"264","line":1,"column":27,"nodeType":"216","messageId":"217","endLine":1,"endColumn":36},{"ruleId":"214","severity":1,"message":"316","line":1,"column":38,"nodeType":"216","messageId":"217","endLine":1,"endColumn":44},{"ruleId":"214","severity":1,"message":"241","line":1,"column":46,"nodeType":"216","messageId":"217","endLine":1,"endColumn":54},{"ruleId":"214","severity":1,"message":"242","line":3,"column":3,"nodeType":"216","messageId":"217","endLine":3,"endColumn":13},{"ruleId":"214","severity":1,"message":"243","line":4,"column":3,"nodeType":"216","messageId":"217","endLine":4,"endColumn":17},{"ruleId":"214","severity":1,"message":"257","line":5,"column":3,"nodeType":"216","messageId":"217","endLine":5,"endColumn":17},{"ruleId":"214","severity":1,"message":"317","line":9,"column":3,"nodeType":"216","messageId":"217","endLine":9,"endColumn":10},{"ruleId":"214","severity":1,"message":"265","line":10,"column":3,"nodeType":"216","messageId":"217","endLine":10,"endColumn":8},{"ruleId":"214","severity":1,"message":"266","line":11,"column":3,"nodeType":"216","messageId":"217","endLine":11,"endColumn":12},{"ruleId":"214","severity":1,"message":"267","line":12,"column":3,"nodeType":"216","messageId":"217","endLine":12,"endColumn":13},{"ruleId":"214","severity":1,"message":"268","line":13,"column":3,"nodeType":"216","messageId":"217","endLine":13,"endColumn":8},{"ruleId":"214","severity":1,"message":"259","line":14,"column":3,"nodeType":"216","messageId":"217","endLine":14,"endColumn":8},{"ruleId":"214","severity":1,"message":"318","line":15,"column":3,"nodeType":"216","messageId":"217","endLine":15,"endColumn":8},{"ruleId":"214","severity":1,"message":"269","line":16,"column":3,"nodeType":"216","messageId":"217","endLine":16,"endColumn":13},{"ruleId":"214","severity":1,"message":"319","line":17,"column":3,"nodeType":"216","messageId":"217","endLine":17,"endColumn":16},{"ruleId":"214","severity":1,"message":"271","line":18,"column":3,"nodeType":"216","messageId":"217","endLine":18,"endColumn":11},{"ruleId":"214","severity":1,"message":"272","line":20,"column":3,"nodeType":"216","messageId":"217","endLine":20,"endColumn":11},{"ruleId":"214","severity":1,"message":"273","line":21,"column":3,"nodeType":"216","messageId":"217","endLine":21,"endColumn":10},{"ruleId":"214","severity":1,"message":"274","line":26,"column":3,"nodeType":"216","messageId":"217","endLine":26,"endColumn":12},{"ruleId":"214","severity":1,"message":"275","line":29,"column":3,"nodeType":"216","messageId":"217","endLine":29,"endColumn":14},{"ruleId":"214","severity":1,"message":"320","line":31,"column":3,"nodeType":"216","messageId":"217","endLine":31,"endColumn":15},{"ruleId":"214","severity":1,"message":"321","line":32,"column":3,"nodeType":"216","messageId":"217","endLine":32,"endColumn":12},{"ruleId":"214","severity":1,"message":"322","line":33,"column":3,"nodeType":"216","messageId":"217","endLine":33,"endColumn":15},{"ruleId":"214","severity":1,"message":"290","line":51,"column":7,"nodeType":"216","messageId":"217","endLine":51,"endColumn":18},"no-native-reassign",["323"],"no-negated-in-lhs",["324"],"no-unused-vars","'useUndo' is defined but never used.","Identifier","unusedVar","'useRedo' is defined but never used.","'MobileBar' is defined but never used.","'h' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'barHeight' and 'sidebarWidth'. Either include them or remove the dependency array.","ArrayExpression",["325"],"'showPreview' is assigned a value but never used.","'images' is assigned a value but never used.","'getIsTrackingHistory' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'addImage', 'allCameras', 'cols', 'mosaicCamera', 'rawSetImageMap', 'rows', 'scene_ref', 'setCameras', 'setImageMap', 'setIsTrackingHistory', and 'viewports'. Either include them or remove the dependency array.",["326"],"React Hook useEffect has a missing dependency: 'scene_ref'. Either include it or remove the dependency array.",["327"],"React Hook useEffect has missing dependencies: 'allCameras' and 'scene_ref'. Either include them or remove the dependency array.",["328"],"'ReadActive' is defined but never used.","'React' is defined but never used.","'zoom_scaler' is defined but never used.","'w' is assigned a value but never used.","'rows' is assigned a value but never used.","'_' is assigned a value but never used.","'__' is assigned a value but never used.","'useState' is defined but never used.","'RecoilRoot' is defined but never used.","'useRecoilState' is defined but never used.","'draw' is defined but never used.","'debounce' is defined but never used.","'throttle' is defined but never used.","'startBatch' is assigned a value but never used.","'endBatch' is assigned a value but never used.","'scroll' is assigned a value but never used.","'ax' is assigned a value but never used.","'ay' is assigned a value but never used.","'aw' is assigned a value but never used.","'ah' is assigned a value but never used.","'filename' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'addImage', 'panCamera', 'scene_ref', 'scroll_ref', 'setActive', 'setImageMap', and 'zoomCamera'. Either include them or remove the dependency array.",["329"],"'useRecoilValue' is defined but never used.","'useRecoilSnapshot' is defined but never used.","'aRows' is defined but never used.","'zoomMode' is assigned a value but never used.","'snapshot' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'activeEscape', 'addCol', 'addImage', 'addRow', 'check', 'copy', 'input_ref', 'logState', 'mosaicCamera', 'moveActive', 'panCamera', 'paste', 'pullCameras', 'pushCameras', 'redo', 'remCol', 'remRow', 'resetZoom', 'resizeActive', 'scene_ref', 'selectAll', 'setGridSize', 'setImageMap', 'setMode', 'setShowCameras', 'setShowGrid', 'setShowPreview', 'setZoomMode', 'shakeCamera', 'shatterCamera', 'undo', and 'zoomCamera'. Either include them or remove the dependency array.",["330"],"'useEffect' is defined but never used.","'aSize' is defined but never used.","'aGridSize' is defined but never used.","'sViewports' is defined but never used.","'aCols' is defined but never used.","'aBarHeight' is defined but never used.","'aSidebar' is defined but never used.","'aCameras' is defined but never used.","'afCamera' is defined but never used.","'aImages' is defined but never used.","'aImageMap' is defined but never used.","'sAllCameras' is defined but never used.","'domLoadImage' is defined but never used.","'Spacer' is defined but never used.","'Tip' is defined but never used.","'sidebarWidth' is assigned a value but never used.","'showCameras' is assigned a value but never used.","'setShowCameras' is assigned a value but never used.","'showGrid' is assigned a value but never used.","'setShowGrid' is assigned a value but never used.","'setShowPreview' is assigned a value but never used.","'moveActive' is assigned a value but never used.","'resizeActive' is assigned a value but never used.","'panCamera' is assigned a value but never used.","'mosaicCamera' is assigned a value but never used.","'shatterCamera' is assigned a value but never used.","'shakeCamera' is assigned a value but never used.","'pushCameras' is assigned a value but never used.","'pullCameras' is assigned a value but never used.","'copy' is assigned a value but never used.","'paste' is assigned a value but never used.","'addCol' is assigned a value but never used.","'remCol' is assigned a value but never used.","'addRow' is assigned a value but never used.","'remRow' is assigned a value but never used.","'resetZoom' is assigned a value but never used.","'addImage' is assigned a value but never used.","'setImageMap' is assigned a value but never used.","'setGridSize' is assigned a value but never used.","'km_ref' is assigned a value but never used.","'undo' is assigned a value but never used.","'redo' is assigned a value but never used.","'input' is assigned a value but never used.","'base_zoom' is defined but never used.","'transformPoint' is defined but never used.","'normalize' is defined but never used.","'viewport' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'click'. Either include it or remove the dependency array.",["331"],["332"],"'REGL' is defined but never used.","'Fragment' is defined but never used.","'useRef' is defined but never used.","'aActive' is defined but never used.","'aMode' is defined but never used.","'aSidebarWidth' is defined but never used.","'aShowCameras' is defined but never used.","'aShowGrid' is defined but never used.","'aShowPreview' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"333","fix":"334"},{"desc":"335","fix":"336"},{"desc":"337","fix":"338"},{"desc":"339","fix":"340"},{"desc":"341","fix":"342"},{"desc":"343","fix":"344"},{"desc":"345","fix":"346"},{"desc":"345","fix":"347"},"Update the dependencies array to be: [setSize, setGridSize, sidebarWidth, barHeight]",{"range":"348","text":"349"},"Update the dependencies array to be: [addImage, allCameras, cols, gridSize, loaded, mosaicCamera, rawSetImageMap, rows, scene_ref, setCameras, setImageMap, setIsTrackingHistory, viewports]",{"range":"350","text":"351"},"Update the dependencies array to be: [loaded, imageMap, scene_ref]",{"range":"352","text":"353"},"Update the dependencies array to be: [loaded, cols, rows, gridSize, viewports, cameras, scene_ref, allCameras]",{"range":"354","text":"355"},"Update the dependencies array to be: [viewports, mode, canvas_ref, active, cols, scene_ref, scroll_ref, setActive, panCamera, zoomCamera, addImage, setImageMap]",{"range":"356","text":"357"},"Update the dependencies array to be: [mode, showGrid, showCameras, showPreview, scene_ref, input_ref, check, undo, redo, logState, moveActive, panCamera, setMode, selectAll, activeEscape, zoomCamera, setZoomMode, addImage, setImageMap, copy, paste, shatterCamera, mosaicCamera, shakeCamera, pushCameras, pullCameras, resetZoom, setShowPreview, setShowGrid, setShowCameras, remCol, addCol, remRow, addRow, resizeActive, setGridSize]",{"range":"358","text":"359"},"Update the dependencies array to be: [click]",{"range":"360","text":"361"},{"range":"362","text":"361"},[3858,3880],"[setSize, setGridSize, sidebarWidth, barHeight]",[14317,14335],"[addImage, allCameras, cols, gridSize, loaded, mosaicCamera, rawSetImageMap, rows, scene_ref, setCameras, setImageMap, setIsTrackingHistory, viewports]",[14459,14477],"[loaded, imageMap, scene_ref]",[14610,14660],"[loaded, cols, rows, gridSize, viewports, cameras, scene_ref, allCameras]",[6993,7036],"[viewports, mode, canvas_ref, active, cols, scene_ref, scroll_ref, setActive, panCamera, zoomCamera, addImage, setImageMap]",[6846,6888],"[mode, showGrid, showCameras, showPreview, scene_ref, input_ref, check, undo, redo, logState, moveActive, panCamera, setMode, selectAll, activeEscape, zoomCamera, setZoomMode, addImage, setImageMap, copy, paste, shatterCamera, mosaicCamera, shakeCamera, pushCameras, pullCameras, resetZoom, setShowPreview, setShowGrid, setShowCameras, remCol, addCol, remRow, addRow, resizeActive, setGridSize]",[16126,16128],"[click]",[17472,17474]]