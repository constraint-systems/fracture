[{"/home/grant/dev/refract/src/index.js":"1","/home/grant/dev/refract/src/App.js":"2","/home/grant/dev/refract/src/reportWebVitals.js":"3","/home/grant/dev/refract/src/State.js":"4","/home/grant/dev/refract/src/Keyboard.js":"5","/home/grant/dev/refract/src/Gl.js":"6","/home/grant/dev/refract/src/gl_utils.js":"7","/home/grant/dev/refract/src/mat4.js":"8","/home/grant/dev/refract/src/constants.js":"9","/home/grant/dev/refract/src/shaders.js":"10","/home/grant/dev/refract/src/Mouse.js":"11","/home/grant/dev/refract/src/Sidebar.js":"12","/home/grant/dev/refract/src/Mobile.js":"13","/home/grant/dev/refract/src/Examples.js":"14"},{"size":521,"mtime":1609615164670,"results":"15","hashOfConfig":"16"},{"size":16762,"mtime":1610506549354,"results":"17","hashOfConfig":"16"},{"size":362,"mtime":1609013397681,"results":"18","hashOfConfig":"16"},{"size":20820,"mtime":1610318892184,"results":"19","hashOfConfig":"16"},{"size":6935,"mtime":1610559289791,"results":"20","hashOfConfig":"16"},{"size":690,"mtime":1609177680124,"results":"21","hashOfConfig":"16"},{"size":16497,"mtime":1610318831916,"results":"22","hashOfConfig":"16"},{"size":9015,"mtime":1609262564992,"results":"23","hashOfConfig":"16"},{"size":111,"mtime":1609865182330,"results":"24","hashOfConfig":"16"},{"size":1061,"mtime":1609283436012,"results":"25","hashOfConfig":"16"},{"size":7080,"mtime":1610506860966,"results":"26","hashOfConfig":"16"},{"size":18311,"mtime":1610559767764,"results":"27","hashOfConfig":"16"},{"size":4029,"mtime":1609899327933,"results":"28","hashOfConfig":"16"},{"size":989,"mtime":1610559654825,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"1hpo407",{"filePath":"33","messages":"34","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"32"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"32"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"32"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"32"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"32"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"60","messages":"61","errorCount":0,"warningCount":47,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"32"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":44,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/grant/dev/refract/src/index.js",[],["65","66"],"/home/grant/dev/refract/src/App.js",["67","68","69","70","71","72","73","74","75","76","77","78"],"import React, { Fragment, useEffect, useRef, useState } from \"react\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport {\n  aActive,\n  aSize,\n  aGridSize,\n  sViewports,\n  aCols,\n  aRows,\n  aMode,\n  aBarHeight,\n  aSidebarWidth,\n  aCameras,\n  afCamera,\n  aImages,\n  sAddImage,\n  aImageMap,\n  sSetImageMap,\n  sMosaicCamera,\n  sAllCameras,\n  aShowCameras,\n  aShowGrid,\n  aShowPreview,\n} from \"./State.js\";\nimport {\n  setProjectionMatrices,\n  setViewMatrix,\n  getWorldFromPx,\n  setViewMatrices,\n} from \"./gl_utils\";\nimport {\n  RecoilUndoRoot,\n  useUndo,\n  useRedo,\n  useIsTrackingHistory,\n} from \"recoil-undo\";\nimport Keyboard from \"./Keyboard\";\nimport Mouse from \"./Mouse\";\nimport MobileBar from \"./Mobile\";\nimport Sidebar from \"./Sidebar\";\nimport REGL from \"regl\";\nimport { base_zoom, mobile } from \"./constants\";\nimport { initImageQuad } from \"./shaders\";\n\nlet id_counter = 0;\nexport function getID() {\n  id_counter++;\n  return id_counter;\n}\n\nfunction Root() {\n  let scene_ref = useRef({\n    viewports: [],\n    projection: [],\n    inverse_projection: [],\n    views: [],\n    view_projections: [],\n    inverse_view_projections: [],\n    image_map: [],\n    image_draws: [],\n    capture: false,\n  });\n  let input_ref = useRef(null);\n  let scroll_ref = useRef(null);\n\n  return (\n    <RecoilRoot>\n      <RecoilUndoRoot trackingByDefault={false}>\n        <input\n          style={{ display: \"none\" }}\n          type=\"file\"\n          accept=\"image/*\"\n          ref={input_ref}\n        />\n        <SizeObserver />\n        <div style={{ position: \"relative\", marginLeft: 4, marginTop: 4 }}>\n          <Canvas scroll_ref={scroll_ref} scene_ref={scene_ref} />\n          <Layers />\n        </div>\n        <Actions scene_ref={scene_ref} input_ref={input_ref} />\n        <Keyboard scene_ref={scene_ref} input_ref={input_ref} />\n      </RecoilUndoRoot>\n    </RecoilRoot>\n  );\n}\n\nexport default Root;\n\nfunction Actions({ input_ref, scene_ref }) {\n  let [w, h] = useRecoilValue(aSize);\n  return w < mobile ? (\n    <Sidebar mobile={true} scene_ref={scene_ref} input_ref={input_ref} />\n  ) : (\n    <Sidebar scene_ref={scene_ref} input_ref={input_ref} />\n  );\n}\n\nfunction Layers() {\n  let showPreview = useRecoilValue(aShowPreview);\n  let showCameras = useRecoilValue(aShowCameras);\n  let showGrid = useRecoilValue(aShowGrid);\n  let mode = useRecoilValue(aMode);\n  return (\n    <React.Fragment>\n      {showPreview ? null : showCameras ? <ShowCameras /> : null}\n      {showPreview ? null : showGrid ? <ShowGrid /> : null}\n      {showPreview || mode === \"canvasResize\" ? null : <ShowActive />}\n      {mode === \"canvasResize\" ? <CanvasResize /> : null}\n    </React.Fragment>\n  );\n}\n\nfunction SizeObserver() {\n  let setSize = useSetRecoilState(aSize);\n  let setGridSize = useSetRecoilState(aGridSize);\n  let barHeight = useRecoilValue(aBarHeight);\n  let sidebarWidth = useRecoilValue(aSidebarWidth);\n\n  useEffect(() => {\n    function setNewSize() {\n      let w = window.innerWidth;\n      let h = window.innerHeight;\n      setSize([w, h]);\n      if (w < mobile) {\n        setGridSize([w - 8, h - 48 * 6 - 8]);\n      } else {\n        setGridSize([w - sidebarWidth - 8, h - barHeight - 12]);\n      }\n    }\n    // setSize([4000 - sidebarWidth - 8, 4000 - barHeight - 12]);\n    // setGridSize([4000 - sidebarWidth - 8, 4000 - barHeight - 12]);\n    setNewSize();\n    window.addEventListener(\"resize\", setNewSize);\n    return () => {\n      window.removeEventListener(\"resize\", setNewSize);\n    };\n  }, [setSize, setGridSize]);\n\n  return null;\n}\n\nfunction CanvasResize() {\n  let cols = useRecoilValue(aCols);\n  let rows = useRecoilValue(aRows);\n  let viewports = useRecoilValue(sViewports);\n\n  let v = viewports[0];\n  return (\n    <div\n      className=\"active-outline resize-canvas\"\n      style={{\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        width: cols * v[2],\n        height: rows * v[3],\n        pointerEvents: \"none\",\n        touchEvents: \"none\",\n      }}\n    ></div>\n  );\n}\n\nfunction ShowActive() {\n  let active = useRecoilValue(aActive);\n  let viewports = useRecoilValue(sViewports);\n  let mode = useRecoilValue(aMode);\n\n  let v = viewports[0];\n  return (\n    <div\n      className=\"active-outline\"\n      style={{\n        position: \"absolute\",\n        left: active[0] * v[2],\n        top: active[1] * v[3],\n        width: active[2] * v[2],\n        height: active[3] * v[3],\n        pointerEvents: \"none\",\n        touchEvents: \"none\",\n      }}\n    >\n      {mode === \"resize\" ? (\n        <Fragment>\n          <div\n            style={{\n              position: \"absolute\",\n              left: 0,\n              top: 0,\n              background: \"#111\",\n              width: 17,\n              height: 17,\n              borderBottom: \"solid 1px white\",\n              borderRight: \"solid 1px white\",\n            }}\n          ></div>\n          <div\n            style={{\n              position: \"absolute\",\n              right: 0,\n              bottom: 0,\n              background: \"#111\",\n              width: 17,\n              height: 17,\n              borderTop: \"solid 1px white\",\n              borderLeft: \"solid 1px white\",\n            }}\n          ></div>\n        </Fragment>\n      ) : null}\n    </div>\n  );\n}\n\nfunction ShowCameras() {\n  let viewports = useRecoilValue(sViewports);\n  let camera_ids = useRecoilValue(aCameras);\n\n  return viewports.map((camera, i) => {\n    let v = viewports[i];\n    let id = camera_ids[i];\n    return (\n      <div\n        key={`camera${i}`}\n        style={{\n          position: \"absolute\",\n          left: v[0],\n          top: v[1],\n          width: v[2],\n          height: v[3],\n          pointerEvents: \"none\",\n          touchEvents: \"none\",\n        }}\n      >\n        <CameraRead id={id} />\n      </div>\n    );\n  });\n}\n\nfunction ShowGrid() {\n  let [width, height] = useRecoilValue(aGridSize);\n  let cols = useRecoilValue(aCols);\n  let rows = useRecoilValue(aRows);\n  let showPreview = useRecoilValue(aShowPreview);\n  let vw = Math.floor(width / cols);\n  let vh = Math.floor(height / rows);\n  let crop_width = vw * cols;\n  let crop_height = vh * rows;\n  let bl = 160;\n  return (\n    <div>\n      {cols > 0\n        ? [...Array(cols - 1)].map((_, c) => {\n            return (\n              <React.Fragment key={`colback_${c}`}>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: (c + 1) * vw - 1.5,\n                    top: 0,\n                    width: 3,\n                    height: crop_height,\n                    background: \"rgba(20,20,20,0.5)\",\n                  }}\n                ></div>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: (c + 1) * vw - 0.5,\n                    top: 0,\n                    width: 1,\n                    height: crop_height,\n                    background: \"rgba(\" + [bl, bl, bl] + \",0.5)\",\n                  }}\n                ></div>\n              </React.Fragment>\n            );\n          })\n        : null}\n\n      {rows > 0\n        ? [...Array(rows - 1)].map((_, r) => {\n            return (\n              <React.Fragment key={`rowback_${r}`}>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: 0,\n                    top: (r + 1) * vh - 1.5,\n                    height: 3,\n                    width: crop_width,\n                    background: \"rgba(20,20,20,0.5)\",\n                  }}\n                ></div>\n                <div\n                  style={{\n                    pointerEvents: \"none\",\n                    touchEvents: \"none\",\n                    position: \"absolute\",\n                    left: 0,\n                    top: (r + 1) * vh - 0.5,\n                    height: 1,\n                    width: crop_width,\n                    background: \"rgba(\" + [bl, bl, bl] + \",0.5)\",\n                  }}\n                ></div>\n              </React.Fragment>\n            );\n          })\n        : null}\n    </div>\n  );\n}\n\nfunction CameraRead({ id }) {\n  let camera = useRecoilValue(afCamera(id));\n  return (\n    <div\n      className=\"outline-text\"\n      style={{\n        position: \"absolute\",\n        fontSize: 12,\n        left: 0,\n        bottom: 8,\n        paddingLeft: 8,\n        paddingRight: 8,\n        color: \"#eee\",\n        userSelect: \"none\",\n        width: \"100%\",\n        overflow: \"hidden\",\n      }}\n    >\n      {camera\n        .map((v) => Math.round((v + Number.EPSILON) * 100) / 100)\n        .join(\",\")}\n    </div>\n  );\n}\n\nexport function loadImage(scene, src, addImage, presetImageMap, callback) {\n  let $img = new Image();\n  $img.onload = function () {\n    // might be a race condition\n    scene.pixel = getWorldFromPx(scene, 1, base_zoom);\n    let w = $img.width * scene.pixel;\n    let h = $img.height * scene.pixel;\n    let x0 = -w / 2;\n    let y0 = h / 2;\n    let x1 = w / 2;\n    let y1 = -h / 2;\n    let place = [x0, y0, x1, y1];\n    addImage($img);\n    let drawImage = initImageQuad(scene, $img, ...place);\n    scene.image_draws.push(drawImage);\n    if (presetImageMap !== undefined) presetImageMap();\n    if (callback !== undefined) {\n      callback();\n    }\n  };\n  $img.src = src;\n}\n\nexport function domLoadImage(scene, input, addImage, presetImageMap) {\n  function handleChange(e) {\n    for (let item of this.files) {\n      if (item.type.indexOf(\"image\") < 0) {\n        continue;\n      }\n      let src = URL.createObjectURL(item);\n      loadImage(scene, src, addImage, presetImageMap);\n      input.value = null;\n    }\n    input.removeEventListener(\"change\", handleChange);\n  }\n  input.addEventListener(\"change\", handleChange);\n\n  input.dispatchEvent(\n    new MouseEvent(\"click\", {\n      bubbles: true,\n      cancelable: true,\n      view: window,\n    })\n  );\n}\n\nfunction Canvas({ scene_ref, scroll_ref }) {\n  let gridSize = useRecoilValue(aGridSize);\n  let viewports = useRecoilValue(sViewports);\n  let cols = useRecoilValue(aCols);\n  let rows = useRecoilValue(aRows);\n  let sidebarWidth = useRecoilValue(aSidebarWidth);\n  let allCameras = useRecoilValue(sAllCameras);\n  let images = useRecoilValue(aImages);\n  let barHeight = useRecoilValue(aBarHeight);\n  let addImage = useSetRecoilState(sAddImage);\n  let [imageMap, rawSetImageMap] = useRecoilState(aImageMap);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let mosaicCamera = useSetRecoilState(sMosaicCamera);\n  let [cameras, setCameras] = useRecoilState(aCameras);\n  let canvas_ref = useRef(null);\n  let regl_ref = useRef(null);\n  let size = useRecoilValue(aSize);\n  let [loaded, setLoaded] = useState(false);\n  const { getIsTrackingHistory, setIsTrackingHistory } = useIsTrackingHistory();\n\n  useEffect(() => {\n    if (gridSize[0] !== null && !loaded) {\n      let regl = REGL(canvas_ref.current);\n      regl_ref.current = regl;\n      let scene = scene_ref.current;\n      scene.regl = regl;\n\n      // init cameras and scene arrays\n      let camera_ids = [];\n      for (let i = 0; i < cols * rows; i++) {\n        let id = getID();\n        camera_ids.push(id);\n        scene.views.push([]);\n        scene.view_projections.push([]);\n        scene.inverse_view_projections.push([]);\n        scene.image_map.push(null);\n      }\n      setCameras(camera_ids);\n      scene.cameras = [...Array(cols * rows)].map((v) => [0, 0, 5]);\n\n      rawSetImageMap([...Array(cols * rows)].map((v) => null));\n\n      setScene();\n\n      loadImage(\n        scene,\n        process.env.PUBLIC_URL + \"/images/ozymandias-screens-watchmen.jpg\",\n        addImage,\n        setImageMap.bind(null, { active: [0, 0, cols, rows] }),\n        () => {\n          mosaicCamera({ scene, active: [0, 0, cols, rows] });\n          setIsTrackingHistory(true);\n        }\n      );\n\n      let gl = canvas_ref.current.getContext(\"webgl\");\n      gl.enable(gl.SCISSOR_TEST);\n\n      regl.frame(({ tick }) => {\n        regl.clear({\n          color: [0, 0, 0, 1],\n        });\n        if (scene.viewports.length > 0) {\n          let vy_offset =\n            scene.gridSize[1] - scene.viewports[0][3] * scene.rows;\n          for (let i = 0; i < scene.viewports.length; i++) {\n            let viewport = scene.viewports[i];\n            let [vx, vy, vw, vh] = viewport;\n            // gap at bottom instead of top\n            vy = vy + vy_offset;\n            gl.viewport(vx, vy, vw, vh);\n            gl.scissor(vx, vy, vw, vh);\n            regl.clear({\n              color: [0, 0, 0, 1],\n            });\n            if (scene.image_map.length > 0 && scene.image_map[i] !== null) {\n              let draw = scene.image_draws[scene.image_map[i]];\n              draw({\n                view_projection: scene.view_projections[i],\n              });\n            }\n          }\n        }\n\n        if (scene.capture) {\n          scene.capture = false;\n          let save_canvas = document.createElement(\"canvas\");\n          save_canvas.width = scene.viewports[0][2] * scene.cols;\n          save_canvas.height = scene.viewports[0][3] * scene.rows;\n          let sx = save_canvas.getContext(\"2d\");\n          sx.drawImage(gl.canvas, 0, 0);\n          let link = document.createElement(\"a\");\n          save_canvas.toBlob(function (blob) {\n            link.setAttribute(\n              \"download\",\n              \"fracture-\" + Math.round(new Date().getTime() / 1000) + \".png\"\n            );\n            link.setAttribute(\"href\", URL.createObjectURL(blob));\n            link.dispatchEvent(\n              new MouseEvent(`click`, {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n              })\n            );\n          });\n        }\n      });\n      setLoaded(true);\n    }\n  }, [gridSize, loaded]);\n\n  useEffect(() => {\n    if (loaded) {\n      let scene = scene_ref.current;\n      scene.image_map = imageMap;\n    }\n  }, [loaded, imageMap]);\n\n  function setScene() {\n    let scene = scene_ref.current;\n\n    let rawCameras = allCameras.slice();\n    let invertedCameras = [];\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols; c++) {\n        let index = r * cols + c;\n        let invert_row = rows - 1 - Math.floor(index / cols);\n        let inverted = invert_row * cols + (index % cols);\n        invertedCameras.push(rawCameras[inverted]);\n      }\n    }\n\n    scene.cameras = invertedCameras;\n    scene.gridSize = gridSize;\n    scene.cols = cols;\n    scene.rows = rows;\n    scene.viewports = viewports;\n\n    setProjectionMatrices(scene);\n\n    scene.views = [];\n    scene.view_projections = [];\n    scene.inverse_view_projections = [];\n    for (let i = 0; i < cols * rows; i++) {\n      scene.views.push([]);\n      scene.view_projections.push([]);\n      scene.inverse_view_projections.push([]);\n    }\n    setViewMatrices(scene);\n  }\n\n  useEffect(() => {\n    if (loaded) {\n      setScene();\n    }\n  }, [loaded, cols, rows, gridSize, viewports, cameras]);\n\n  return gridSize[0] !== null ? (\n    <div\n      ref={scroll_ref}\n      style={{\n        width: gridSize[0] + (size[0] > mobile ? sidebarWidth : 0) + 4,\n        height: gridSize[1] + (size[0] > mobile ? barHeight + 8 : 4),\n        userSelect: \"none\",\n        touchAction: \"none\",\n      }}\n    >\n      <canvas width={gridSize[0]} height={gridSize[1]} ref={canvas_ref}>\n        {cameras.map((id, index) => (\n          <CanvasCamera key={id} id={id} index={index} scene_ref={scene_ref} />\n        ))}\n        <Mouse\n          canvas_ref={canvas_ref}\n          scene_ref={scene_ref}\n          scroll_ref={scroll_ref}\n        />\n      </canvas>\n    </div>\n  ) : null;\n}\n\nfunction CanvasCamera({ id, index, scene_ref }) {\n  let camera = useRecoilValue(afCamera(id));\n\n  useEffect(() => {\n    let scene = scene_ref.current;\n\n    let invert_row = scene.rows - 1 - Math.floor(index / scene.cols);\n    let inverted = invert_row * scene.cols + (index % scene.cols);\n\n    scene.cameras[inverted] = camera;\n    setViewMatrix(scene, inverted);\n  }, [id, index, camera, scene_ref]);\n\n  return null;\n}\n\nfunction ReadActive() {\n  let [x, y, w, h] = useRecoilValue(aActive);\n  let [gw, gh] = useRecoilValue(aGridSize);\n  let size = useRecoilValue(aSize);\n  let mode = useRecoilValue(aMode);\n  return size[0] > mobile ? (\n    <div style={{ position: \"fixed\", left: 0, bottom: 0, display: \"flex\" }}>\n      {mode === \"canvasResize\" ? (\n        <div style={{ background: \"#111\", padding: 8 }}>\n          {gw}x{gh}\n        </div>\n      ) : (\n        <div style={{ background: \"#111\", padding: 8 }}>\n          â–¡ {x},{y} {w}x{h}\n        </div>\n      )}\n    </div>\n  ) : null;\n}\n","/home/grant/dev/refract/src/reportWebVitals.js",[],"/home/grant/dev/refract/src/State.js",["79","80","81","82","83","84","85"],"import React from \"react\";\nimport { atom, atomFamily, selector } from \"recoil\";\nimport { getWorldFromPx, castRay } from \"./gl_utils\";\nimport { base_zoom, zoom_scaler } from \"./constants\";\nimport { getID } from \"./App\";\n\nexport let aScene = atom({\n  key: \"scene\",\n  default: {},\n});\n\nexport let aActive = atom({\n  key: \"active\",\n  default: [2, 1, 1, 1],\n});\n\nexport let a_Mode = atom({\n  key: \"mode\",\n  default: \"normal\",\n});\n\nexport let aMode = selector({\n  key: \"sMode\",\n  get: ({ get }) => {\n    return get(a_Mode);\n  },\n  set: ({ set }, name) => {\n    set(a_Mode, name);\n  },\n});\n\nexport let aSize = atom({\n  key: \"size\",\n  default: [null, null],\n});\n\nexport let aGridSize = atom({\n  key: \"gridSize\",\n  default: [null, null],\n});\n\nexport let sGridSize = selector({\n  key: \"changeGridSize\",\n  set: ({ get, set }, diff) => {\n    let [dx, dy] = diff;\n    let [w, h] = get(aGridSize).slice();\n    let wlimit = Math.max(64, w + dx * 8);\n    let hlimit = Math.max(64, h + dy * 8);\n    set(aGridSize, [wlimit, hlimit]);\n  },\n});\n\nexport let aCols = atom({\n  key: \"cols\",\n  default: 4,\n});\n\nexport let aRows = atom({\n  key: \"rows\",\n  default: 4,\n});\n\nexport let aBarHeight = atom({\n  key: \"barHeight\",\n  default: 0,\n});\n\nexport let aSidebarWidth = atom({\n  key: \"sidebarWidth\",\n  default: 360,\n});\n\nexport let aCameras = atom({\n  key: \"cameras\",\n  default: [],\n});\n\nexport let afCamera = atomFamily({\n  key: \"camera\",\n  default: [0, 0, 5],\n});\n\nexport let aImageMap = atom({\n  key: \"imageMap\",\n  default: [],\n});\n\nexport let aImages = atom({\n  key: \"images\",\n  default: [],\n});\n\nexport let sAddImage = selector({\n  key: \"addImage\",\n  set: ({ get, set }, img) => {\n    let imgs = get(aImages);\n    set(aImages, [...imgs, img]);\n  },\n});\n\nfunction constrainActive(active, cols, rows) {\n  let [x, y, w, h] = active;\n  if (w > cols) w = cols;\n  if (h > rows) h = rows;\n  return [minmax(x, 0, cols - w), minmax(y, 0, rows - h), w, h];\n}\n\nfunction minmax(val, min, max) {\n  return Math.max(min, Math.min(max, val));\n}\n\nexport let sActiveSelector = selector({\n  key: \"activeSelector\",\n  set: ({ get, set }, new_value) => {\n    set(aActive, constrainActive(new_value, get(aCols), get(aRows)));\n  },\n});\n\nexport let sSelectAll = selector({\n  key: \"selectAll\",\n  set: ({ get, set }, new_value) => {\n    set(aActive, [0, 0, get(aCols), get(aRows)]);\n  },\n});\n\nexport let sMoveActiveSelector = selector({\n  key: \"moveActiveSelector\",\n  set: ({ get, set }, diff) => {\n    let [x, y, w, h] = get(aActive);\n    let [dx, dy] = diff;\n    set(sActiveSelector, [x + dx, y + dy, w, h]);\n  },\n});\n\nfunction constrainResize(active, cols, rows) {\n  let [x, y, w, h] = active;\n  let wlimit = cols - active[0];\n  let hlimit = rows - active[1];\n  return [x, y, minmax(w, 1, wlimit), minmax(h, 1, hlimit)];\n}\n\nexport let sResizeActiveSelector = selector({\n  key: \"resizeActiveSelector\",\n  set: ({ get, set }, diff) => {\n    let [x, y, w, h] = get(aActive);\n    let [dx, dy] = diff;\n    let new_value = [x, y, w + dx, h + dy];\n    set(aActive, constrainResize(new_value, get(aCols), get(aRows)));\n  },\n});\n\nexport let sViewports = selector({\n  key: \"viewports\",\n  get: ({ get }) => {\n    let [w, h] = get(aGridSize);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let vw = Math.floor(w / cols);\n    let vh = Math.floor(h / rows);\n    return [...Array(cols * rows)].map((_, i) => {\n      let c = i % cols;\n      let r = Math.floor(i / cols);\n      return [c * vw, r * vh, vw, vh];\n    });\n  },\n});\n\nexport let sPanCamera = selector({\n  key: \"panCamera\",\n  set: ({ get, set }, { scene, diff }) => {\n    let [dx, dy] = diff;\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let [x, y, w, h] = get(aActive);\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let ndx = getWorldFromPx(scene, dx, new_camera[2]);\n        let ndy = getWorldFromPx(scene, dy, new_camera[2]);\n        new_camera[0] -= ndx;\n        new_camera[1] += ndy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sActiveEscape = selector({\n  key: \"activeEscape\",\n  set: ({ get, set }) => {\n    let [x, y, w, h] = get(aActive);\n    set(aActive, [x, y, 1, 1]);\n  },\n});\n\nexport let sResetZoom = selector({\n  key: \"resetZoom\",\n  set: ({ get, set }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let [x, y, w, h] = get(aActive);\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        new_camera[2] = base_zoom;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sAllCameras = selector({\n  key: \"allCameras\",\n  get: ({ get }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let expandedCameras = [];\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols; c++) {\n        let index = r * cols + c;\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        expandedCameras.push(camera);\n      }\n    }\n    return expandedCameras;\n  },\n});\n\nexport let sMosaicCamera = selector({\n  key: \"mosaicCamera\",\n  set: ({ get, set }, { scene, active }) => {\n    let cameras = get(aCameras);\n    let viewports = get(sViewports);\n    let [gw, gh] = get(aGridSize);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let get_active;\n    if (active === undefined) {\n      get_active = get(aActive);\n    } else {\n      get_active = active;\n    }\n    let [x, y, w, h] = get_active;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        let id = cameras[index];\n        let [vx, vy, vw, vh] = viewports[inverted];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let midx = vx + vw / 2;\n        let midy = vy + vh / 2;\n        let difx = midx - gw / 2;\n        let dify = midy - gh / 2;\n        let w = getWorldFromPx(scene, difx, new_camera[2]);\n        let h = getWorldFromPx(scene, dify, new_camera[2]);\n        new_camera[0] = w;\n        new_camera[1] = h;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sShakeCamera = selector({\n  key: \"shakeCamera\",\n  set: ({ get, set }, { scene, active }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let get_active;\n    if (active === undefined) {\n      get_active = get(aActive);\n    } else {\n      get_active = active;\n    }\n    let [x, y, w, h] = get_active;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let nd = getWorldFromPx(scene, 24, new_camera[2]);\n        let dx = 0 - nd / 2 + Math.random() * nd;\n        let dy = 0 - nd / 2 + Math.random() * nd;\n        new_camera[0] += dx;\n        new_camera[1] += dy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sPushCameras = selector({\n  key: \"pushCameras\",\n  set: ({ get, set }, { scene, active }) => {\n    let [x, y, w, h] = get(aActive);\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let c1 = x + w / 2;\n    let c2 = y + h / 2;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let dx = 0;\n        let dy = 0;\n        if (c1 < c + x + 0.5) {\n          dx = -1;\n        } else if (c1 > c + x + 0.5) {\n          dx = 1;\n        }\n        if (c2 < r + y + 0.5) {\n          dy = 1;\n        } else if (c2 > r + y + 0.5) {\n          dy = -1;\n        }\n        let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n        let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n        new_camera[0] += ndx;\n        new_camera[1] += ndy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sPullCameras = selector({\n  key: \"pullCameras\",\n  set: ({ get, set }, { scene, active }) => {\n    let [x, y, w, h] = get(aActive);\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let c1 = x + w / 2;\n    let c2 = y + h / 2;\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let dx = 0;\n        let dy = 0;\n        if (c1 < c + x + 0.5) {\n          dx = 1;\n        } else if (c1 > c + x + 0.5) {\n          dx = -1;\n        }\n        if (c2 < r + y + 0.5) {\n          dy = -1;\n        } else if (c2 > r + y + 0.5) {\n          dy = 1;\n        }\n        let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n        let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n        new_camera[0] += ndx;\n        new_camera[1] += ndy;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sShatterCamera = selector({\n  key: \"shatterCamera\",\n  set: ({ get, set }, scene) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let [x, y, w, h] = get(aActive);\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        new_camera[0] = 0;\n        new_camera[1] = 0;\n        set(afCamera(id), new_camera);\n      }\n    }\n  },\n});\n\nexport let sSetImageMap = selector({\n  key: \"setImageMap\",\n  set: ({ get, set }, { active }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let get_active;\n    if (active === undefined) {\n      get_active = get(aActive);\n    } else {\n      get_active = active;\n    }\n    let [x, y, w, h] = get_active;\n    let images = get(aImages);\n    let new_map = get(aImageMap).slice();\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        new_map[inverted] = images.length - 1;\n      }\n    }\n    set(aImageMap, new_map);\n  },\n});\n\nfunction zoomLimit(new_zoom) {\n  let max = 100;\n  let min = 0.01;\n  return Math.min(max, Math.max(min, new_zoom));\n}\n\nexport let aZoomMode = atom({\n  key: \"zoomMode\",\n  default: \"canvas\",\n});\n\nexport let aShowCameras = atom({\n  key: \"showCameras\",\n  default: false,\n});\n\nexport let aShowGrid = atom({\n  key: \"showGrid\",\n  default: true,\n});\n\nexport let aShowPreview = atom({\n  key: \"showPreview\",\n  default: false,\n});\n\nexport let aCopy = atom({\n  key: \"copy\",\n  default: [],\n});\n\nexport let sCopy = selector({\n  key: \"setCopy\",\n  set: ({ get, set }) => {\n    let [x, y, w, h] = get(aActive);\n    let imageMap = get(aImageMap);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let cameras = get(aCameras);\n    let copy = [];\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let map = imageMap[inverted];\n        let obj = [camera.slice(), map];\n        copy.push(obj);\n      }\n    }\n    set(aCopy, copy);\n  },\n});\n\nexport let sPaste = selector({\n  key: \"setPaste\",\n  set: ({ get, set }) => {\n    let copy = get(aCopy);\n    if (copy.length > 0) {\n      let [x, y, w, h] = get(aActive);\n      let imageMap = get(aImageMap);\n      let newMap = imageMap.slice();\n      let cols = get(aCols);\n      let rows = get(aRows);\n      let cameras = get(aCameras);\n      let copy = get(aCopy);\n      for (let r = 0; r < h; r++) {\n        for (let c = 0; c < w; c++) {\n          let copyIndex = r * w + c;\n          if (copy[copyIndex] === undefined) copyIndex = copy.length - 1;\n          let [new_camera, new_map] = copy[copyIndex];\n          let index = (y + r) * cols + (x + c);\n          let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n          let id = cameras[index];\n          newMap[inverted] = new_map;\n          set(afCamera(id), new_camera);\n        }\n      }\n      set(aImageMap, newMap);\n    }\n  },\n});\n\nexport let sZoomCamera = selector({\n  key: \"zoomCamera\",\n  set: ({ get, set }, { scene, sign, mult }) => {\n    let cameras = get(aCameras);\n    let cols = get(aCols);\n    let rows = get(aRows);\n    let [x, y, w, h] = get(aActive);\n    let [gw, gh] = get(aGridSize);\n    let zoomMode = get(aZoomMode);\n    let viewports = get(sViewports);\n    let [xp, yp] = viewports[(rows - (y + h)) * cols + x];\n    let [_, __, vw, vh] = viewports[0];\n    let active_size = [vw * w, vh * h];\n    for (let r = 0; r < h; r++) {\n      for (let c = 0; c < w; c++) {\n        let index = (y + r) * cols + (x + c);\n        let inverted = (rows - 1 - (y + r)) * cols + (x + c);\n        let id = cameras[index];\n        let camera = get(afCamera(id));\n        let new_camera = camera.slice();\n        let zoom = new_camera[2];\n        let new_poss;\n        if (sign > 0) {\n          new_poss = zoom * mult;\n        } else {\n          new_poss = zoom / mult;\n        }\n        let new_zoom = zoomLimit(new_poss);\n        if (new_zoom > zoom || new_zoom < zoom) {\n          if (zoomMode === \"canvas\") {\n            let projected = castRay(\n              scene,\n              inverted,\n              [gw / 2, gh / 2],\n              new_zoom\n            );\n            new_camera = [...projected, new_zoom];\n          } else if (zoomMode === \"active\") {\n            let projected = castRay(\n              scene,\n              inverted,\n              [xp + active_size[0] / 2, yp + active_size[1] / 2],\n              new_zoom\n            );\n            new_camera = [...projected, new_zoom];\n          } else {\n            new_camera[2] = new_zoom;\n          }\n          set(afCamera(id), new_camera);\n        }\n      }\n    }\n  },\n});\n\nexport let sAddCol = selector({\n  key: \"addCol\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (cols < 10) {\n      let [x, y, w, h] = get(aActive);\n      let insertCol = x + w;\n      let lastCol = insertCol - 1;\n\n      let imageMap = get(aImageMap);\n      let mapCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapCols[c].push(imageMap[index]);\n        }\n      }\n      let copyCol = mapCols[lastCol].slice();\n      mapCols.splice(insertCol, 0, copyCol);\n      let recombinedMap = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < mapCols.length; c++) {\n          recombinedMap.push(mapCols[c][r]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraCols[c].push(cameras[index]);\n        }\n      }\n      let copyCameras = cameraCols[lastCol].slice();\n      let newCol = [];\n      for (let r = 0; r < rows; r++) {\n        let id = getID();\n        let copyID = copyCameras[r];\n        let cloneCamera = get(afCamera(copyID)).slice();\n        set(afCamera(id), cloneCamera);\n        newCol.push(id);\n      }\n      cameraCols.splice(insertCol, 0, newCol);\n      let recombinedCameras = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cameraCols.length; c++) {\n          recombinedCameras.push(cameraCols[c][r]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aCols, cols + 1);\n      set(aActive, [x, y, w + 1, h]);\n    }\n  },\n});\n\nexport let sRemCol = selector({\n  key: \"remCol\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (cols > 1) {\n      let [x, y, w, h] = get(aActive);\n      let firstCol = x;\n\n      let imageMap = get(aImageMap);\n      let mapCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapCols[c].push(imageMap[index]);\n        }\n      }\n      mapCols.splice(firstCol, 1);\n      let recombinedMap = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < mapCols.length; c++) {\n          recombinedMap.push(mapCols[c][r]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraCols = [...Array(cols)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraCols[c].push(cameras[index]);\n        }\n      }\n      cameraCols.splice(firstCol, 1);\n      let recombinedCameras = [];\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cameraCols.length; c++) {\n          recombinedCameras.push(cameraCols[c][r]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aCols, cols - 1);\n      if (w > 1) {\n        set(aActive, constrainActive([x, y, w - 1, h], cols - 1, rows));\n      } else {\n        set(aActive, constrainActive([x - 1, y, w, h], cols - 1, rows));\n      }\n    }\n  },\n});\n\nexport let sAddRow = selector({\n  key: \"addRow\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (rows < 8) {\n      let [x, y, w, h] = get(aActive);\n      let insertRow = y + h;\n      let lastRow = insertRow - 1;\n\n      let imageMap = get(aImageMap);\n      let mapRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapRows[r].push(imageMap[index]);\n        }\n      }\n      let copyRow = mapRows[lastRow].slice();\n      mapRows.splice(insertRow, 0, copyRow);\n      let recombinedMap = [];\n      for (let r = 0; r < mapRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedMap.push(mapRows[r][c]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraRows[r].push(cameras[index]);\n        }\n      }\n      let copyCameras = cameraRows[lastRow].slice();\n      let newRow = [];\n      for (let c = 0; c < cols; c++) {\n        let id = getID();\n        let copyID = copyCameras[c];\n        let cloneCamera = get(afCamera(copyID)).slice();\n        set(afCamera(id), cloneCamera);\n        newRow.push(id);\n      }\n      cameraRows.splice(insertRow, 0, newRow);\n      let recombinedCameras = [];\n      for (let r = 0; r < cameraRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedCameras.push(cameraRows[r][c]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aRows, rows + 1);\n      set(aActive, [x, y, w, h + 1]);\n    }\n  },\n});\n\nexport let sRemRow = selector({\n  key: \"remRoww\",\n  set: ({ get, set }) => {\n    let cols = get(aCols);\n    let rows = get(aRows);\n    if (rows > 1) {\n      let [x, y, w, h] = get(aActive);\n      let firstRow = y;\n\n      let imageMap = get(aImageMap);\n      let mapRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          mapRows[r].push(imageMap[index]);\n        }\n      }\n      mapRows.splice(firstRow, 1);\n      let recombinedMap = [];\n      for (let r = 0; r < mapRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedMap.push(mapRows[r][c]);\n        }\n      }\n\n      let cameras = get(aCameras);\n      let cameraRows = [...Array(rows)].map((n) => []);\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          let index = r * cols + c;\n          cameraRows[r].push(cameras[index]);\n        }\n      }\n      cameraRows.splice(firstRow, 1);\n      let recombinedCameras = [];\n      for (let r = 0; r < cameraRows.length; r++) {\n        for (let c = 0; c < cols; c++) {\n          recombinedCameras.push(cameraRows[r][c]);\n        }\n      }\n\n      set(aCameras, recombinedCameras);\n      set(aImageMap, recombinedMap);\n      set(aRows, rows - 1);\n      if (h > 1) {\n        set(aActive, constrainActive([x, y, w, h - 1], cols, rows - 1));\n      } else {\n        set(aActive, constrainActive([x - 1, y, w, h], cols, rows - 1));\n      }\n    }\n  },\n});\n","/home/grant/dev/refract/src/Keyboard.js",["86","87","88","89","90","91","92","93"],"/home/grant/dev/refract/src/Gl.js",["94"],"import REGL from \"regl\";\n\nexport function draw(regl) {\n  return regl({\n    frag: `\n    precision mediump float;\n    uniform vec4 color;\n    void main() {\n      gl_FragColor = color;\n    }`,\n\n    vert: `\n    precision mediump float;\n    attribute vec2 position;\n    uniform float angle;\n    void main() {\n      gl_Position = vec4(\n        cos(angle) * position.x + sin(angle) * position.y,\n        -sin(angle) * position.x + cos(angle) * position.y, 0, 1);\n    }`,\n\n    attributes: {\n      position: [-1, 0, 0, -1, 1, 1],\n    },\n\n    uniforms: {\n      color: regl.prop(\"color\"),\n      angle: ({ tick }) => 0.01 * tick,\n    },\n\n    depth: {\n      enable: false,\n    },\n\n    count: 3,\n  });\n}\n","/home/grant/dev/refract/src/gl_utils.js",["95","96","97","98","99","100","101"],"import { base_zoom, start_zoom, zoom_scaler } from \"./constants.js\";\nimport {\n  perspective,\n  lookAt,\n  multiply,\n  invert,\n  multiplyPoint,\n  transformPoint,\n  normalize,\n} from \"./mat4.js\";\n\nexport function setViewports(scene, $render, cols, rows) {\n  let w = Math.floor($render.width / cols);\n  let h = Math.floor($render.height / rows);\n  scene.viewports = [];\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      scene.viewports.push([c * w, r * h, w, h]);\n    }\n  }\n}\n\nexport function initImageMap(scene, cols, rows) {\n  scene.viewport_image_map = [];\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      scene.viewport_image_map.push(null);\n    }\n  }\n}\n\nexport function initCameras(scene) {\n  scene.cameras = [];\n  scene.projection = [];\n  scene.inverse_projection = [];\n  scene.views = [];\n  scene.view_projections = [];\n  scene.inverse_view_projections = [];\n  for (let i = 0; i < scene.viewports.length; i++) {\n    scene.cameras.push([0, 0, start_zoom]);\n    scene.views.push([]);\n    scene.view_projections.push([]);\n    scene.inverse_view_projections.push([]);\n  }\n}\n\nexport function setProjectionMatrices(scene) {\n  if (scene.viewports.length > 0) {\n    let w = scene.viewports[0][2];\n    let h = scene.viewports[0][3];\n    perspective(scene.projection, Math.PI / 3, w / h, 0.01, 100);\n    invert(scene.inverse_projection, scene.projection);\n  }\n}\n\nfunction getLookAt(camera) {\n  return [camera[0], camera[1], 0];\n}\n\nexport function setViewMatrix(scene, i) {\n  let camera = scene.cameras[i];\n  if (scene.views[i]) {\n    lookAt(scene.views[i], camera, getLookAt(camera), [0, 1, 0]);\n    multiply(scene.view_projections[i], scene.projection, scene.views[i]);\n    invert(scene.inverse_view_projections[i], scene.view_projections[i]);\n  }\n}\n\nexport function setViewMatrices(scene) {\n  for (let i = 0; i < scene.cameras.length; i++) {\n    let camera = scene.cameras[i];\n    lookAt(scene.views[i], camera, getLookAt(camera), [0, 1, 0]);\n    multiply(scene.view_projections[i], scene.projection, scene.views[i]);\n    invert(scene.inverse_view_projections[i], scene.view_projections[i]);\n  }\n}\n\nexport function getProjectionZ(scene, world_z) {\n  let projected = multiplyPoint(scene.projection, [0, 0, world_z, 1]);\n  let ndz = projected[2] / projected[3];\n  return ndz;\n}\n\nexport function getWorldFromPx(scene, px, camera_dist) {\n  let z = getProjectionZ(scene, -camera_dist);\n  let raw = [(2 * px) / scene.viewports[0][2], 0, z, 1];\n  let point_world = multiplyPoint(scene.inverse_projection, raw);\n  return point_world[0] / point_world[3];\n}\n\nexport function mosaic(scene, indexes) {\n  let $render = scene.$render;\n  // need matrices to be initialized already\n  if (indexes === undefined) indexes = scene.group;\n  for (let i of indexes) {\n    let [vx, vy, vw, vh] = scene.viewports[i];\n    let camera = scene.cameras[i];\n    let midx = vx + vw / 2;\n    let midy = vy + vh / 2;\n    let difx = midx - $render.width / 2;\n    let dify = midy - $render.height / 2;\n    let w = getWorldFromPx(scene, difx, camera[2]);\n    let h = getWorldFromPx(scene, dify, camera[2]);\n    scene.cameras[i][0] = w;\n    scene.cameras[i][1] = h;\n  }\n}\n\nexport function panSetPixels(scene, x, y) {\n  let indexes = scene.active;\n  for (let index of indexes) {\n    let viewport = scene.viewports[index];\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, x * 8, camera[2]);\n    let ndy = getWorldFromPx(scene, y * 8, camera[2]);\n    scene.cameras[index][0] += ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function panViewports(scene, dx, dy) {\n  let indexes = scene.active;\n  for (let index of indexes) {\n    let viewport = scene.viewports[index];\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, dx, camera[2]);\n    let ndy = getWorldFromPx(scene, dy, camera[2]);\n    scene.cameras[index][0] -= ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function getClipsFromMouse(viewport, mouse_position) {\n  let ratio_x = (mouse_position[0] - viewport[0]) / viewport[2];\n  let ratio_y = (mouse_position[1] - viewport[1]) / viewport[3];\n  let clip_x = 2 * ratio_x - 1;\n  let clip_y = 2 * ratio_y - 1;\n  return [clip_x, clip_y];\n}\n\nexport function castRay(scene, index, mouse, world_z) {\n  let viewport = scene.viewports[index];\n  let ndz = getNormalizedZ(scene, index, world_z);\n  let clips = getClipsFromMouse(viewport, mouse);\n  let device_coordinates = [clips[0], clips[1], ndz, 1];\n  let point_world = multiplyPoint(\n    scene.inverse_view_projections[index],\n    device_coordinates\n  );\n  // divide by w at end\n  let world_points = [\n    point_world[0] / point_world[3],\n    point_world[1] / point_world[3],\n  ];\n  return world_points;\n}\n\nfunction zoomLimit(new_zoom) {\n  let max = 99;\n  let min = 0.01;\n  return Math.min(max, Math.max(min, new_zoom));\n}\n\nexport function zoomCenter(scene, sign) {\n  let indexes = scene.active;\n  for (let i of indexes) {\n    let zoom = scene.cameras[i][2];\n    let new_cam;\n    if (sign === 1) {\n      new_cam = scene.cameras[i][2] * zoom_scaler;\n    } else {\n      new_cam = scene.cameras[i][2] / zoom_scaler;\n    }\n    let new_zoom = zoomLimit(new_cam);\n    if (new_zoom > zoom || new_zoom < zoom) {\n      if (scene.zoom_mode === \"canvas\") {\n        let projected = castRay(\n          scene,\n          i,\n          [scene.width / 2, scene.height / 2],\n          new_zoom\n        );\n        scene.cameras[i] = [...projected, new_zoom];\n      } else if (scene.zoom_mode === \"active\") {\n        // TODO figure out if this is what you sant\n        let viewport = scene.viewports[scene.active];\n        let projected = castRay(\n          scene,\n          i,\n          [viewport[0] + viewport[2] / 2, viewport[1] + viewport[3] / 2],\n          new_zoom\n        );\n        scene.cameras[i] = [...projected, new_zoom];\n      } else if (scene.zoom_mode === \"every\") {\n        scene.cameras[i][2] = new_zoom;\n      }\n    }\n  }\n}\n\nexport function getNormalizedZ(scene, index, world_z) {\n  let projected = multiplyPoint(scene.view_projections[index], [\n    0,\n    0,\n    world_z,\n    1,\n  ]);\n  let ndz = projected[2] / projected[3];\n  return ndz;\n}\n\nexport function shake(scene) {\n  let indexes = scene.active;\n  for (let i = 0; i < indexes.length; i++) {\n    let index = indexes[i];\n    let camera = scene.cameras[index];\n    let nx = getWorldFromPx(scene, 16, camera[2]);\n    let dx = 1 - 2 * Math.random();\n    let dy = 1 - 2 * Math.random();\n    scene.cameras[index][0] += dx * nx;\n    scene.cameras[index][1] += dy * nx;\n  }\n}\n\nexport function viewportCenter(scene) {\n  let indexes = scene.active;\n  for (let index of indexes) {\n    scene.cameras[index][0] = 0;\n    scene.cameras[index][1] = 0;\n  }\n}\n\nexport function minMaxOrder(v1, v2) {\n  let min = Math.min(v1, v2);\n  let max = Math.max(v1, v2);\n  return [min, max];\n}\n\nexport function moveGroupWithFocus(group_selected, mactive, cols, rows) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let mx = mactive % cols;\n  let my = Math.floor(mactive / cols);\n  let start_col = x1;\n  let start_row = y1;\n  let end_col = x2;\n  let end_row = y2;\n  let w = x2 - x1;\n  let h = y2 - y1;\n  if (mx < x1) {\n    start_col = mx;\n    end_col = start_col + w;\n  } else if (mx > x2) {\n    end_col = mx;\n    start_col = end_col - w;\n  }\n  if (my < y1) {\n    start_row = my;\n    end_row = start_row + h;\n  } else if (my > y2) {\n    end_row = my;\n    start_row = end_row - h;\n  }\n  let g1 = start_row * cols + start_col;\n  let g2 = end_row * rows + end_col;\n  return [g1, g2];\n}\n\nexport function resizeGroupWithFocus(group_selected, mactive, cols, rows) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let mx = mactive % cols;\n  let my = Math.floor(mactive / cols);\n  let start_col = x1;\n  let start_row = y1;\n  let end_col = x2;\n  let end_row = y2;\n  let w = x2 - x1;\n  let h = y2 - y1;\n  if (mx < x1) {\n    start_col = mx;\n  } else if (mx > x2) {\n    end_col = mx;\n  }\n  if (my < y1) {\n    start_row = my;\n  } else if (my > y2) {\n    end_row = my;\n  }\n  let g1 = start_row * cols + start_col;\n  let g2 = end_row * cols + end_col;\n  return [g1, g2];\n}\n\nexport function resizeRelative(group_selected, cols, rows, dx, dy) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let end_col = Math.min(cols - 1, Math.max(x1, x2 + dx));\n  let end_row = Math.min(rows - 1, Math.max(y1, y2 + dy));\n  return end_row * cols + end_col;\n}\n\nexport function confineActive(group_selected, mactive, cols, rows) {\n  let x1 = group_selected[0] % cols;\n  let y1 = Math.floor(group_selected[0] / cols);\n  let x2 = group_selected[1] % cols;\n  let y2 = Math.floor(group_selected[1] / cols);\n  let mx = mactive % cols;\n  let my = Math.floor(mactive / cols);\n  if (mx < x1) {\n    mx = x1;\n  } else if (mx > x2) {\n    mx = x2;\n  }\n  if (my < y1) {\n    my = y1;\n  } else if (my > y2) {\n    my = y2;\n  }\n  return my * cols + mx;\n}\n\nexport function getGroupIndexes(group, cols, rows) {\n  let x1 = group[0] % cols;\n  let y1 = Math.floor(group[0] / cols);\n  let x2 = group[1] % cols;\n  let y2 = Math.floor(group[1] / cols);\n  let indexes = [];\n  for (let r = 0; r < y2 - y1; r++) {\n    for (let c = 0; c < x2 - x1; c++) {\n      indexes.push(r * cols + c);\n    }\n  }\n  return indexes;\n}\n\nexport function push(scene) {\n  let group = scene.active;\n  let [x1, y1, x2, y2] = getVertices(scene.group, scene.cols, scene.rows);\n  let c1 = x1 + (x2 - x1 + 1) / 2;\n  let c2 = y1 + (y2 - y1 + 1) / 2;\n  for (let index of group) {\n    let c = (index % scene.cols) + 0.5;\n    let r = Math.floor(index / scene.cols) + 0.5;\n    let dx = 0;\n    let dy = 0;\n    if (c1 < c) {\n      dx = -1;\n    } else if (c1 > c) {\n      dx = 1;\n    }\n    if (c2 < r) {\n      dy = -1;\n    } else if (c2 > r) {\n      dy = 1;\n    }\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n    let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n    scene.cameras[index][0] += ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function pull(scene) {\n  let group = scene.active;\n  let [x1, y1, x2, y2] = getVertices(scene.group, scene.cols, scene.rows);\n  let c1 = x1 + (x2 - x1 + 1) / 2;\n  let c2 = y1 + (y2 - y1 + 1) / 2;\n  for (let index of group) {\n    let c = (index % scene.cols) + 0.5;\n    let r = Math.floor(index / scene.cols) + 0.5;\n    let dx = 0;\n    let dy = 0;\n    if (c1 < c) {\n      dx = 1;\n    } else if (c1 > c) {\n      dx = -1;\n    }\n    if (c2 < r) {\n      dy = 1;\n    } else if (c2 > r) {\n      dy = -1;\n    }\n    let camera = scene.cameras[index];\n    let ndx = getWorldFromPx(scene, dx * 8, camera[2]);\n    let ndy = getWorldFromPx(scene, dy * 8, camera[2]);\n    scene.cameras[index][0] += ndx;\n    scene.cameras[index][1] += ndy;\n  }\n}\n\nexport function resetZoom(scene) {\n  let group = scene.active;\n  for (let index of group) {\n    scene.cameras[index][2] = start_zoom;\n  }\n}\n\nexport function copy(scene) {\n  let group = scene.active;\n  let copy_array = [];\n  for (let index of group) {\n    let camera = scene.cameras[index];\n    let image = scene.viewport_image_map[index];\n    let container = [camera, image];\n    copy_array.push(container);\n  }\n  scene.copy_buffer = copy_array;\n}\n\nexport function paste(scene) {\n  let buffer = scene.copy_buffer;\n  let group = scene.active;\n  if (buffer !== null) {\n    let i = 0;\n    for (let copy of buffer) {\n      let [camera, image] = JSON.parse(JSON.stringify(copy));\n      if (group[i] !== undefined) {\n        let index = group[i];\n        scene.cameras[index] = camera;\n        scene.viewport_image_map[index] = image;\n      }\n      i++;\n    }\n  }\n}\n\nexport function moveVertices(v, dx, dy) {\n  v[0] += dx;\n  v[1] += dy;\n  v[2] += dx;\n  v[3] += dy;\n  return v;\n}\n\nexport function getVertices(group, cols, rows) {\n  let x1 = group[0] % cols;\n  let y1 = Math.floor(group[0] / cols);\n  let x2 = group[1] % cols;\n  let y2 = Math.floor(group[1] / cols);\n  let gx1 = Math.min(x1, x2);\n  let gy1 = Math.min(y1, y2);\n  let gx2 = Math.max(x1, x2);\n  let gy2 = Math.max(y1, y2);\n  return [gx1, gy1, gx2, gy2];\n}\n\nexport function getIndexes(v, cols, rows) {\n  let [gx1, gy1, gx2, gy2] = v;\n  let i1 = gy1 * cols + gx1;\n  let i2 = gy2 * cols + gx2;\n  return [i1, i2];\n}\n\nexport function confineVertices(v, cols, rows) {\n  let [x1, y1, x2, y2] = v;\n  if (x1 < 0) {\n    let diff = -x1;\n    x1 += diff;\n    x2 += diff;\n  }\n  if (x2 > cols - 1) {\n    let diff = x2 - (cols - 1);\n    x1 -= diff;\n    x2 -= diff;\n  }\n  // too wide\n  if (x1 < 0) {\n    x1 = 0;\n  }\n  if (y1 < 0) {\n    let diff = -y1;\n    y1 += diff;\n    y2 += diff;\n  }\n  if (y2 > rows - 1) {\n    let diff = y2 - (rows - 1);\n    y1 -= diff;\n    y2 -= diff;\n  }\n  // too tall\n  if (y1 < 0) {\n    y1 = 0;\n  }\n  return [x1, y1, x2, y2];\n}\n\nexport function moveRelative(group, cols, rows, dx, dy) {\n  let v = moveVertices(getVertices(group, cols, rows), dx, dy);\n  v = confineVertices(v, cols, rows);\n  return getIndexes(v, cols, rows);\n}\n\nexport function confineToCanvas(group, cols, rows) {\n  let v = getVertices(group, cols, rows);\n  v = confineVertices(v, cols, rows);\n  return getIndexes(v, cols, rows);\n}\n\nexport function moveAbsolute(group, cols, rows, index) {\n  let [x1, y1, x2, y2] = getVertices(group, cols, rows);\n  let w = x2 - x1;\n  let h = y2 - y1;\n  let xoff1 = Math.floor(w / 2);\n  let xoff2 = w - xoff1;\n  let yoff1 = Math.floor(h / 2);\n  let yoff2 = h - yoff1;\n  let tar = getVertices([index, index], cols, rows);\n  let nx1 = tar[0] - xoff1;\n  let nx2 = tar[0] + xoff2;\n  let ny1 = tar[1] - yoff1;\n  let ny2 = tar[1] + yoff2;\n  let v = confineVertices([nx1, ny1, nx2, ny2], cols, rows);\n  return getIndexes(v, cols, rows);\n}\n\nexport function addSceneCol(scene, col) {\n  let $render = scene.$render;\n  let copied = [];\n  for (let r = 0; r < scene.rows; r++) {\n    let index = r * scene.cols + col;\n    let camera = scene.cameras[index];\n    let image = scene.viewport_image_map[index];\n    let container = [camera, image];\n    copied.push(container);\n  }\n  scene.cols += 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let r = 0; r < scene.rows; r++) {\n    let copy = JSON.parse(JSON.stringify(copied[r]));\n    let index = r * scene.cols + col;\n    scene.viewport_image_map.splice(index, 0, copy[1]);\n    scene.cameras.splice(index, 0, copy[0]);\n    scene.views.splice(index, 0, []);\n    scene.view_projections.splice(index, 0, []);\n    scene.inverse_view_projections.splice(index, 0, []);\n  }\n}\n\nexport function addSceneRow(scene, row) {\n  let $render = scene.$render;\n  let copied = [];\n  for (let c = 0; c < scene.cols; c++) {\n    let index = row * scene.cols + c;\n    let camera = scene.cameras[index];\n    let image = scene.viewport_image_map[index];\n    let container = [camera, image];\n    copied.push(container);\n  }\n  scene.rows += 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let c = 0; c < scene.cols; c++) {\n    let copy = JSON.parse(JSON.stringify(copied[c]));\n    let index = row * scene.cols + c;\n    scene.viewport_image_map.splice(index, 0, copy[1]);\n    scene.cameras.splice(index, 0, copy[0]);\n    scene.views.splice(index, 0, []);\n    scene.view_projections.splice(index, 0, []);\n    scene.inverse_view_projections.splice(index, 0, []);\n  }\n}\n\nexport function remSceneCol(scene, col) {\n  let $render = scene.$render;\n  scene.cols -= 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let r = 0; r < scene.rows; r++) {\n    let index = r * scene.cols + col;\n    scene.viewport_image_map.splice(index, 1);\n    scene.cameras.splice(index, 1);\n    scene.views.splice(index, 1);\n    scene.view_projections.splice(index, 1);\n    scene.inverse_view_projections.splice(index, 1);\n  }\n}\n\nexport function remSceneRow(scene, row) {\n  let $render = scene.$render;\n  scene.rows -= 1;\n  setViewports(scene, $render, scene.cols, scene.rows);\n  for (let c = 0; c < scene.cols; c++) {\n    // index is different bc it is chopping one each time\n    let index = row * scene.cols;\n    scene.viewport_image_map.splice(index, 1);\n    scene.cameras.splice(index, 1);\n    scene.views.splice(index, 1);\n    scene.view_projections.splice(index, 1);\n    scene.inverse_view_projections.splice(index, 1);\n  }\n}\n","/home/grant/dev/refract/src/mat4.js",[],"/home/grant/dev/refract/src/constants.js",[],"/home/grant/dev/refract/src/shaders.js",[],"/home/grant/dev/refract/src/Mouse.js",["102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117"],"import React, { useState, useEffect, useRef } from \"react\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport { draw } from \"./Gl.js\";\nimport {\n  aActive,\n  sViewports,\n  sPanCamera,\n  aCols,\n  sActiveSelector,\n  sSetImageMap,\n  sZoomCamera,\n  aMode,\n  sAddImage,\n} from \"./State.js\";\nimport { useBatching } from \"recoil-undo\";\nimport { loadImage } from \"./App\";\n\nfunction debounce(func, wait, immediate) {\n  var timeout;\n  return function () {\n    var context = this,\n      args = arguments;\n    var later = function () {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n\nfunction throttle(callback, limit) {\n  var waiting = false; // Initially, we're not waiting\n  return function () {\n    // We return a throttled function\n    if (!waiting) {\n      // If we're not waiting\n      callback.apply(this, arguments); // Execute users function\n      waiting = true; // Prevent future invocations\n      setTimeout(function () {\n        // After a period of time\n        waiting = false; // And allow future invocations\n      }, limit);\n    }\n  };\n}\n\nfunction Mouse({ canvas_ref, scene_ref, scroll_ref }) {\n  let mouse_ref = useRef({\n    raw: [0, 0],\n    down: false,\n    drag_start: null,\n    scrollCheck: [0, 0],\n  });\n  let viewports = useRecoilValue(sViewports);\n  let panCamera = useSetRecoilState(sPanCamera);\n  let active = useRecoilValue(aActive);\n  let cols = useRecoilValue(aCols);\n  let mode = useRecoilValue(aMode);\n  let setActive = useSetRecoilState(sActiveSelector);\n  let zoomCamera = useSetRecoilState(sZoomCamera);\n  let addImage = useSetRecoilState(sAddImage);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let { startBatch, endBatch } = useBatching();\n\n  useEffect(() => {\n    function getViewportFromMouse(mouse_raw) {\n      let [mx, my] = mouse_raw;\n      for (let i = 0; i < viewports.length; i++) {\n        let viewport = viewports[i];\n        let [x, y, w, h] = viewport;\n        let col = i % cols;\n        let row = Math.floor(i / cols);\n        if (mx >= x && mx <= x + w && my >= y && my <= y + h) {\n          return [col, row];\n        }\n      }\n    }\n\n    let canvas = canvas_ref.current;\n    let mouse = mouse_ref.current;\n    let scene = scene_ref.current;\n    let scroll = scroll_ref.current;\n\n    function mouseMove(e) {\n      e.preventDefault();\n      if (e.clientX !== mouse.raw[0] && e.clientY !== mouse.raw[1]) {\n        if (mouse.scroll) {\n          let dx = e.clientX - mouse.scrollCheck[0];\n          let dy = e.clientY - mouse.scrollCheck[1];\n          window.scrollBy(-dx, -dy);\n          mouse.scrollCheck = [e.clientX, e.clientY];\n          return false;\n        }\n        var rect = e.target.getBoundingClientRect();\n        var x = e.clientX - rect.left;\n        var y = e.clientY - rect.top;\n        if (mouse.down) {\n          if (mode === \"resize\") {\n            let [ax, ay, aw, ah] = active;\n            let [mx, my] = getViewportFromMouse(mouse.raw);\n            let ax2 = ax + aw - 1;\n            let ay2 = ay + ah - 1;\n            let nx = Math.min(mx, ax);\n            let ny = Math.min(my, ay);\n            let nx2 = Math.max(mx, ax2);\n            let ny2 = Math.max(my, ay2);\n            let w = nx2 - nx + 1;\n            let h = ny2 - ny + 1;\n            setActive([nx, ny, w, h]);\n          } else {\n            let dx = x - mouse.raw[0];\n            let dy = y - mouse.raw[1];\n            panCamera({ scene, diff: [dx, dy] });\n          }\n        }\n        mouse.raw = [x, y];\n      }\n    }\n    function mouseDown(e) {\n      e.preventDefault();\n      // startBatch();\n      if (e.ctrlKey) {\n        mouse.scroll = true;\n        canvas.setPointerCapture(e.pointerId);\n        mouse.scrollCheck = [e.clientX, e.clientY];\n        return false;\n      }\n      var rect = e.target.getBoundingClientRect();\n      var x = e.clientX - rect.left; //x position within the element.\n      var y = e.clientY - rect.top;\n      mouse.raw = [x, y];\n      if (mode === \"resize\") {\n        let [ax, ay, aw, ah] = active;\n        let [mcol, mrow] = getViewportFromMouse(mouse.raw);\n        setActive([mcol, mrow, 1, 1]);\n        mouse.down = true;\n      } else if (mode === \"normal\") {\n        let [ax, ay, aw, ah] = active;\n        let [mcol, mrow] = getViewportFromMouse(mouse.raw);\n        if (mcol >= ax && mcol < ax + aw && mrow >= ay && mrow < ay + ah) {\n          mouse.down = true;\n        } else {\n          setActive([\n            mcol - Math.round((aw - 1) / 2),\n            mrow - Math.round((ah - 1) / 2),\n            aw,\n            ah,\n          ]);\n          mouse.down = true;\n        }\n      }\n      canvas.setPointerCapture(e.pointerId);\n    }\n    function mouseUp(e) {\n      e.preventDefault();\n      // endBatch();\n      mouse.down = false;\n      mouse.scroll = false;\n      canvas.releasePointerCapture(e.pointerId);\n    }\n    function mouseWheel(e) {\n      e.preventDefault();\n\n      if (mode === \"normal\") {\n        let sign = e.deltaY < 0 ? -1 : 1;\n        let mult = 1;\n        let abs = Math.abs(e.deltaY);\n        if (abs > 25) {\n          mult = 1.125;\n        } else {\n          mult = 1 + 0.125 * (abs / 80);\n        }\n        zoomCamera({ scene, sign, mult });\n      }\n    }\n\n    function onDrop(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      let file = e.dataTransfer.files[0];\n      let filename = file.path ? file.path : file.name ? file.name : \"\";\n      let src = URL.createObjectURL(file);\n      loadImage(scene, src, addImage);\n    }\n\n    function onDrag(e) {\n      e.stopPropagation();\n      e.preventDefault();\n      e.dataTransfer.dropEffect = \"copy\";\n    }\n\n    function onPaste(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log(\"paste\");\n      for (const item of e.clipboardData.items) {\n        if (item.type.indexOf(\"image\") < 0) {\n          continue;\n        }\n        let file = item.getAsFile();\n        let src = URL.createObjectURL(file);\n        loadImage(scene, src, addImage, setImageMap.bind(null, {}));\n      }\n    }\n\n    canvas.addEventListener(\"pointermove\", mouseMove);\n    canvas.addEventListener(\"pointerdown\", mouseDown);\n    canvas.addEventListener(\"pointerup\", mouseUp);\n    canvas.addEventListener(\"wheel\", mouseWheel, { passive: false });\n    window.addEventListener(\"paste\", onPaste);\n    window.addEventListener(\"dragover\", onDrag);\n    window.addEventListener(\"drop\", onDrop);\n    return () => {\n      canvas.removeEventListener(\"pointermove\", mouseMove);\n      canvas.removeEventListener(\"pointerdown\", mouseDown);\n      canvas.removeEventListener(\"pointerup\", mouseUp);\n      canvas.removeEventListener(\"wheel\", mouseWheel);\n      window.removeEventListener(\"paste\", onPaste);\n      window.removeEventListener(\"dragover\", onDrag);\n      window.removeEventListener(\"drop\", onDrop);\n    };\n  }, [viewports, mode, canvas_ref, active, cols]);\n\n  return null;\n}\n\nexport default Mouse;\n","/home/grant/dev/refract/src/Sidebar.js",["118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134"],"/home/grant/dev/refract/src/Mobile.js",["135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181"],"import React, { useEffect, useRef, useState } from \"react\";\nimport {\n  aSize,\n  aGridSize,\n  sViewports,\n  aCols,\n  aRows,\n  aMode,\n  aBarHeight,\n  aSidebar,\n  aCameras,\n  afCamera,\n  aImages,\n  sAddImage,\n  aImageMap,\n  sSetImageMap,\n  aSidebarWidth,\n  sMosaicCamera,\n  sAllCameras,\n  sMoveActiveSelector,\n  sResizeActiveSelector,\n  sPanCamera,\n  sZoomCamera,\n  sShatterCamera,\n  sSelectAll,\n  sShakeCamera,\n  sPushCameras,\n  sPullCameras,\n  sAddCol,\n  sRemCol,\n  sAddRow,\n  sRemRow,\n  sResetZoom,\n  sActiveEscape,\n  aShowCameras,\n  aShowGrid,\n  aZoomMode,\n  aShowPreview,\n  sCopy,\n  sPaste,\n  sGridSize,\n} from \"./State.js\";\nimport { domLoadImage } from \"./App\";\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilValue,\n  useSetRecoilState,\n} from \"recoil\";\nimport { useUndo, useRedo } from \"recoil-undo\";\nimport {\n  ToggleKeyButton,\n  KeyButton,\n  Spacer,\n  Info,\n  Tip,\n  HSpacer,\n} from \"./Sidebar\";\n\nfunction MobileBar({ scene_ref, input_ref }) {\n  let sidebarWidth = useRecoilValue(aSidebarWidth);\n  let [mode, setMode] = useRecoilState(aMode);\n  let [zoomMode, setZoomMode] = useRecoilState(aZoomMode);\n  let [showCameras, setShowCameras] = useRecoilState(aShowCameras);\n  let [showGrid, setShowGrid] = useRecoilState(aShowGrid);\n  let [showPreview, setShowPreview] = useRecoilState(aShowPreview);\n  let moveActive = useSetRecoilState(sMoveActiveSelector);\n  let resizeActive = useSetRecoilState(sResizeActiveSelector);\n  let zoomCamera = useSetRecoilState(sZoomCamera);\n  let panCamera = useSetRecoilState(sPanCamera);\n  let mosaicCamera = useSetRecoilState(sMosaicCamera);\n  let shatterCamera = useSetRecoilState(sShatterCamera);\n  let shakeCamera = useSetRecoilState(sShakeCamera);\n  let pushCameras = useSetRecoilState(sPushCameras);\n  let pullCameras = useSetRecoilState(sPullCameras);\n  let selectAll = useSetRecoilState(sSelectAll);\n  let copy = useSetRecoilState(sCopy);\n  let paste = useSetRecoilState(sPaste);\n  let addCol = useSetRecoilState(sAddCol);\n  let remCol = useSetRecoilState(sRemCol);\n  let addRow = useSetRecoilState(sAddRow);\n  let remRow = useSetRecoilState(sRemRow);\n  let resetZoom = useSetRecoilState(sResetZoom);\n  let activeEscape = useSetRecoilState(sActiveEscape);\n  let addImage = useSetRecoilState(sAddImage);\n  let setImageMap = useSetRecoilState(sSetImageMap);\n  let setGridSize = useSetRecoilState(sGridSize);\n  let km_ref = useRef({});\n  let undo = useUndo();\n  let redo = useRedo();\n\n  let resize = mode === \"resize\";\n  let scene = scene_ref.current;\n  let input = input_ref.current;\n\n  return (\n    <div\n      style={{\n        paddingLeft: 8,\n        paddingRight: 8,\n      }}\n    >\n      <HSpacer />\n      <div\n        style={{\n          display: \"flex\",\n          justifyContent: \"space-between\",\n          alignItems: \"center\",\n        }}\n      >\n        <div>\n          <ToggleKeyButton\n            text=\"Resize selection\"\n            compare={resize}\n            click={setMode.bind(null, resize ? \"normal\" : \"resize\")}\n          />\n        </div>\n        <div>\n          Zoom:{\" \"}\n          <KeyButton\n            text=\"+\"\n            click={zoomCamera.bind(null, { scene, sign: -1 })}\n          />\n          <KeyButton\n            text=\"-\"\n            click={zoomCamera.bind(null, { scene, sign: 1 })}\n          />\n        </div>\n      </div>\n      <div>\n        <KeyButton text=\"Select all\" click={selectAll} />\n        <KeyButton text=\"Clear\" click={activeEscape} />\n      </div>\n      <HSpacer />\n      <Info>Zoom center</Info>\n      <div>\n        <ToggleKeyButton\n          text=\"Canvas\"\n          compare={zoomMode === \"canvas\"}\n          click={setZoomMode.bind(null, \"canvas\")}\n        />\n        <ToggleKeyButton\n          text=\"Individual\"\n          compare={zoomMode === \"individual\"}\n          click={setZoomMode.bind(null, \"individual\")}\n        />\n        <ToggleKeyButton\n          text=\"Active\"\n          compare={zoomMode === \"active\"}\n          click={setZoomMode.bind(null, \"active\")}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default MobileBar;\n","/home/grant/dev/refract/src/Examples.js",["182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225"],{"ruleId":"226","replacedBy":"227"},{"ruleId":"228","replacedBy":"229"},{"ruleId":"230","severity":1,"message":"231","line":38,"column":3,"nodeType":"232","messageId":"233","endLine":38,"endColumn":10},{"ruleId":"230","severity":1,"message":"234","line":39,"column":3,"nodeType":"232","messageId":"233","endLine":39,"endColumn":10},{"ruleId":"230","severity":1,"message":"235","line":44,"column":8,"nodeType":"232","messageId":"233","endLine":44,"endColumn":17},{"ruleId":"230","severity":1,"message":"236","line":95,"column":11,"nodeType":"232","messageId":"233","endLine":95,"endColumn":12},{"ruleId":"237","severity":1,"message":"238","line":142,"column":6,"nodeType":"239","endLine":142,"endColumn":28,"suggestions":"240"},{"ruleId":"230","severity":1,"message":"241","line":250,"column":7,"nodeType":"232","messageId":"233","endLine":250,"endColumn":18},{"ruleId":"230","severity":1,"message":"242","line":405,"column":7,"nodeType":"232","messageId":"233","endLine":405,"endColumn":13},{"ruleId":"230","severity":1,"message":"243","line":416,"column":11,"nodeType":"232","messageId":"233","endLine":416,"endColumn":31},{"ruleId":"237","severity":1,"message":"244","line":508,"column":6,"nodeType":"239","endLine":508,"endColumn":24,"suggestions":"245"},{"ruleId":"237","severity":1,"message":"246","line":515,"column":6,"nodeType":"239","endLine":515,"endColumn":24,"suggestions":"247"},{"ruleId":"237","severity":1,"message":"248","line":554,"column":6,"nodeType":"239","endLine":554,"endColumn":56,"suggestions":"249"},{"ruleId":"230","severity":1,"message":"250","line":596,"column":10,"nodeType":"232","messageId":"233","endLine":596,"endColumn":20},{"ruleId":"230","severity":1,"message":"251","line":1,"column":8,"nodeType":"232","messageId":"233","endLine":1,"endColumn":13},{"ruleId":"230","severity":1,"message":"252","line":4,"column":21,"nodeType":"232","messageId":"233","endLine":4,"endColumn":32},{"ruleId":"230","severity":1,"message":"253","line":194,"column":16,"nodeType":"232","messageId":"233","endLine":194,"endColumn":17},{"ruleId":"230","severity":1,"message":"236","line":194,"column":19,"nodeType":"232","messageId":"233","endLine":194,"endColumn":20},{"ruleId":"230","severity":1,"message":"254","line":380,"column":9,"nodeType":"232","messageId":"233","endLine":380,"endColumn":13},{"ruleId":"230","severity":1,"message":"255","line":515,"column":10,"nodeType":"232","messageId":"233","endLine":515,"endColumn":11},{"ruleId":"230","severity":1,"message":"256","line":515,"column":13,"nodeType":"232","messageId":"233","endLine":515,"endColumn":15},{"ruleId":"230","severity":1,"message":"257","line":1,"column":29,"nodeType":"232","messageId":"233","endLine":1,"endColumn":37},{"ruleId":"230","severity":1,"message":"258","line":3,"column":3,"nodeType":"232","messageId":"233","endLine":3,"endColumn":13},{"ruleId":"230","severity":1,"message":"259","line":5,"column":3,"nodeType":"232","messageId":"233","endLine":5,"endColumn":17},{"ruleId":"230","severity":1,"message":"260","line":7,"column":3,"nodeType":"232","messageId":"233","endLine":7,"endColumn":20},{"ruleId":"230","severity":1,"message":"261","line":39,"column":3,"nodeType":"232","messageId":"233","endLine":39,"endColumn":8},{"ruleId":"230","severity":1,"message":"262","line":48,"column":8,"nodeType":"232","messageId":"233","endLine":48,"endColumn":16},{"ruleId":"230","severity":1,"message":"263","line":75,"column":9,"nodeType":"232","messageId":"233","endLine":75,"endColumn":17},{"ruleId":"237","severity":1,"message":"264","line":228,"column":6,"nodeType":"239","endLine":228,"endColumn":48,"suggestions":"265"},{"ruleId":"230","severity":1,"message":"266","line":1,"column":8,"nodeType":"232","messageId":"233","endLine":1,"endColumn":12},{"ruleId":"230","severity":1,"message":"267","line":1,"column":10,"nodeType":"232","messageId":"233","endLine":1,"endColumn":19},{"ruleId":"230","severity":1,"message":"268","line":8,"column":3,"nodeType":"232","messageId":"233","endLine":8,"endColumn":17},{"ruleId":"230","severity":1,"message":"269","line":9,"column":3,"nodeType":"232","messageId":"233","endLine":9,"endColumn":12},{"ruleId":"230","severity":1,"message":"270","line":112,"column":9,"nodeType":"232","messageId":"233","endLine":112,"endColumn":17},{"ruleId":"230","severity":1,"message":"270","line":124,"column":9,"nodeType":"232","messageId":"233","endLine":124,"endColumn":17},{"ruleId":"230","severity":1,"message":"253","line":282,"column":7,"nodeType":"232","messageId":"233","endLine":282,"endColumn":8},{"ruleId":"230","severity":1,"message":"236","line":283,"column":7,"nodeType":"232","messageId":"233","endLine":283,"endColumn":8},{"ruleId":"230","severity":1,"message":"251","line":1,"column":8,"nodeType":"232","messageId":"233","endLine":1,"endColumn":13},{"ruleId":"230","severity":1,"message":"257","line":1,"column":17,"nodeType":"232","messageId":"233","endLine":1,"endColumn":25},{"ruleId":"230","severity":1,"message":"258","line":3,"column":3,"nodeType":"232","messageId":"233","endLine":3,"endColumn":13},{"ruleId":"230","severity":1,"message":"271","line":4,"column":3,"nodeType":"232","messageId":"233","endLine":4,"endColumn":17},{"ruleId":"230","severity":1,"message":"272","line":8,"column":10,"nodeType":"232","messageId":"233","endLine":8,"endColumn":14},{"ruleId":"230","severity":1,"message":"273","line":23,"column":10,"nodeType":"232","messageId":"233","endLine":23,"endColumn":18},{"ruleId":"230","severity":1,"message":"274","line":39,"column":10,"nodeType":"232","messageId":"233","endLine":39,"endColumn":18},{"ruleId":"230","severity":1,"message":"275","line":71,"column":9,"nodeType":"232","messageId":"233","endLine":71,"endColumn":19},{"ruleId":"230","severity":1,"message":"276","line":71,"column":21,"nodeType":"232","messageId":"233","endLine":71,"endColumn":29},{"ruleId":"230","severity":1,"message":"277","line":90,"column":9,"nodeType":"232","messageId":"233","endLine":90,"endColumn":15},{"ruleId":"230","severity":1,"message":"278","line":141,"column":14,"nodeType":"232","messageId":"233","endLine":141,"endColumn":16},{"ruleId":"230","severity":1,"message":"279","line":141,"column":18,"nodeType":"232","messageId":"233","endLine":141,"endColumn":20},{"ruleId":"230","severity":1,"message":"280","line":141,"column":22,"nodeType":"232","messageId":"233","endLine":141,"endColumn":24},{"ruleId":"230","severity":1,"message":"281","line":141,"column":26,"nodeType":"232","messageId":"233","endLine":141,"endColumn":28},{"ruleId":"230","severity":1,"message":"282","line":189,"column":11,"nodeType":"232","messageId":"233","endLine":189,"endColumn":19},{"ruleId":"237","severity":1,"message":"283","line":230,"column":6,"nodeType":"239","endLine":230,"endColumn":49,"suggestions":"284"},{"ruleId":"230","severity":1,"message":"257","line":1,"column":36,"nodeType":"232","messageId":"233","endLine":1,"endColumn":44},{"ruleId":"230","severity":1,"message":"285","line":3,"column":3,"nodeType":"232","messageId":"233","endLine":3,"endColumn":8},{"ruleId":"230","severity":1,"message":"286","line":4,"column":3,"nodeType":"232","messageId":"233","endLine":4,"endColumn":12},{"ruleId":"230","severity":1,"message":"287","line":5,"column":3,"nodeType":"232","messageId":"233","endLine":5,"endColumn":13},{"ruleId":"230","severity":1,"message":"288","line":6,"column":3,"nodeType":"232","messageId":"233","endLine":6,"endColumn":8},{"ruleId":"230","severity":1,"message":"261","line":7,"column":3,"nodeType":"232","messageId":"233","endLine":7,"endColumn":8},{"ruleId":"230","severity":1,"message":"289","line":9,"column":3,"nodeType":"232","messageId":"233","endLine":9,"endColumn":13},{"ruleId":"230","severity":1,"message":"290","line":10,"column":3,"nodeType":"232","messageId":"233","endLine":10,"endColumn":11},{"ruleId":"230","severity":1,"message":"291","line":11,"column":3,"nodeType":"232","messageId":"233","endLine":11,"endColumn":11},{"ruleId":"230","severity":1,"message":"292","line":12,"column":3,"nodeType":"232","messageId":"233","endLine":12,"endColumn":11},{"ruleId":"230","severity":1,"message":"293","line":13,"column":3,"nodeType":"232","messageId":"233","endLine":13,"endColumn":10},{"ruleId":"230","severity":1,"message":"294","line":15,"column":3,"nodeType":"232","messageId":"233","endLine":15,"endColumn":12},{"ruleId":"230","severity":1,"message":"295","line":19,"column":3,"nodeType":"232","messageId":"233","endLine":19,"endColumn":14},{"ruleId":"230","severity":1,"message":"258","line":45,"column":3,"nodeType":"232","messageId":"233","endLine":45,"endColumn":13},{"ruleId":"230","severity":1,"message":"296","line":105,"column":7,"nodeType":"232","messageId":"233","endLine":105,"endColumn":13},{"ruleId":"237","severity":1,"message":"297","line":539,"column":6,"nodeType":"239","endLine":539,"endColumn":8,"suggestions":"298"},{"ruleId":"237","severity":1,"message":"297","line":588,"column":6,"nodeType":"239","endLine":588,"endColumn":8,"suggestions":"299"},{"ruleId":"230","severity":1,"message":"300","line":1,"column":17,"nodeType":"232","messageId":"233","endLine":1,"endColumn":26},{"ruleId":"230","severity":1,"message":"257","line":1,"column":36,"nodeType":"232","messageId":"233","endLine":1,"endColumn":44},{"ruleId":"230","severity":1,"message":"285","line":3,"column":3,"nodeType":"232","messageId":"233","endLine":3,"endColumn":8},{"ruleId":"230","severity":1,"message":"286","line":4,"column":3,"nodeType":"232","messageId":"233","endLine":4,"endColumn":12},{"ruleId":"230","severity":1,"message":"287","line":5,"column":3,"nodeType":"232","messageId":"233","endLine":5,"endColumn":13},{"ruleId":"230","severity":1,"message":"288","line":6,"column":3,"nodeType":"232","messageId":"233","endLine":6,"endColumn":8},{"ruleId":"230","severity":1,"message":"261","line":7,"column":3,"nodeType":"232","messageId":"233","endLine":7,"endColumn":8},{"ruleId":"230","severity":1,"message":"289","line":9,"column":3,"nodeType":"232","messageId":"233","endLine":9,"endColumn":13},{"ruleId":"230","severity":1,"message":"290","line":10,"column":3,"nodeType":"232","messageId":"233","endLine":10,"endColumn":11},{"ruleId":"230","severity":1,"message":"291","line":11,"column":3,"nodeType":"232","messageId":"233","endLine":11,"endColumn":11},{"ruleId":"230","severity":1,"message":"292","line":12,"column":3,"nodeType":"232","messageId":"233","endLine":12,"endColumn":11},{"ruleId":"230","severity":1,"message":"293","line":13,"column":3,"nodeType":"232","messageId":"233","endLine":13,"endColumn":10},{"ruleId":"230","severity":1,"message":"294","line":15,"column":3,"nodeType":"232","messageId":"233","endLine":15,"endColumn":12},{"ruleId":"230","severity":1,"message":"295","line":19,"column":3,"nodeType":"232","messageId":"233","endLine":19,"endColumn":14},{"ruleId":"230","severity":1,"message":"301","line":43,"column":10,"nodeType":"232","messageId":"233","endLine":43,"endColumn":22},{"ruleId":"230","severity":1,"message":"258","line":45,"column":3,"nodeType":"232","messageId":"233","endLine":45,"endColumn":13},{"ruleId":"230","severity":1,"message":"302","line":54,"column":3,"nodeType":"232","messageId":"233","endLine":54,"endColumn":9},{"ruleId":"230","severity":1,"message":"303","line":56,"column":3,"nodeType":"232","messageId":"233","endLine":56,"endColumn":6},{"ruleId":"230","severity":1,"message":"304","line":61,"column":7,"nodeType":"232","messageId":"233","endLine":61,"endColumn":19},{"ruleId":"230","severity":1,"message":"305","line":64,"column":8,"nodeType":"232","messageId":"233","endLine":64,"endColumn":19},{"ruleId":"230","severity":1,"message":"306","line":64,"column":21,"nodeType":"232","messageId":"233","endLine":64,"endColumn":35},{"ruleId":"230","severity":1,"message":"307","line":65,"column":8,"nodeType":"232","messageId":"233","endLine":65,"endColumn":16},{"ruleId":"230","severity":1,"message":"308","line":65,"column":18,"nodeType":"232","messageId":"233","endLine":65,"endColumn":29},{"ruleId":"230","severity":1,"message":"241","line":66,"column":8,"nodeType":"232","messageId":"233","endLine":66,"endColumn":19},{"ruleId":"230","severity":1,"message":"309","line":66,"column":21,"nodeType":"232","messageId":"233","endLine":66,"endColumn":35},{"ruleId":"230","severity":1,"message":"310","line":67,"column":7,"nodeType":"232","messageId":"233","endLine":67,"endColumn":17},{"ruleId":"230","severity":1,"message":"311","line":68,"column":7,"nodeType":"232","messageId":"233","endLine":68,"endColumn":19},{"ruleId":"230","severity":1,"message":"312","line":70,"column":7,"nodeType":"232","messageId":"233","endLine":70,"endColumn":16},{"ruleId":"230","severity":1,"message":"313","line":71,"column":7,"nodeType":"232","messageId":"233","endLine":71,"endColumn":19},{"ruleId":"230","severity":1,"message":"314","line":72,"column":7,"nodeType":"232","messageId":"233","endLine":72,"endColumn":20},{"ruleId":"230","severity":1,"message":"315","line":73,"column":7,"nodeType":"232","messageId":"233","endLine":73,"endColumn":18},{"ruleId":"230","severity":1,"message":"316","line":74,"column":7,"nodeType":"232","messageId":"233","endLine":74,"endColumn":18},{"ruleId":"230","severity":1,"message":"317","line":75,"column":7,"nodeType":"232","messageId":"233","endLine":75,"endColumn":18},{"ruleId":"230","severity":1,"message":"318","line":77,"column":7,"nodeType":"232","messageId":"233","endLine":77,"endColumn":11},{"ruleId":"230","severity":1,"message":"319","line":78,"column":7,"nodeType":"232","messageId":"233","endLine":78,"endColumn":12},{"ruleId":"230","severity":1,"message":"320","line":79,"column":7,"nodeType":"232","messageId":"233","endLine":79,"endColumn":13},{"ruleId":"230","severity":1,"message":"321","line":80,"column":7,"nodeType":"232","messageId":"233","endLine":80,"endColumn":13},{"ruleId":"230","severity":1,"message":"322","line":81,"column":7,"nodeType":"232","messageId":"233","endLine":81,"endColumn":13},{"ruleId":"230","severity":1,"message":"323","line":82,"column":7,"nodeType":"232","messageId":"233","endLine":82,"endColumn":13},{"ruleId":"230","severity":1,"message":"324","line":83,"column":7,"nodeType":"232","messageId":"233","endLine":83,"endColumn":16},{"ruleId":"230","severity":1,"message":"325","line":85,"column":7,"nodeType":"232","messageId":"233","endLine":85,"endColumn":15},{"ruleId":"230","severity":1,"message":"326","line":86,"column":7,"nodeType":"232","messageId":"233","endLine":86,"endColumn":18},{"ruleId":"230","severity":1,"message":"327","line":87,"column":7,"nodeType":"232","messageId":"233","endLine":87,"endColumn":18},{"ruleId":"230","severity":1,"message":"296","line":88,"column":7,"nodeType":"232","messageId":"233","endLine":88,"endColumn":13},{"ruleId":"230","severity":1,"message":"328","line":89,"column":7,"nodeType":"232","messageId":"233","endLine":89,"endColumn":11},{"ruleId":"230","severity":1,"message":"329","line":90,"column":7,"nodeType":"232","messageId":"233","endLine":90,"endColumn":11},{"ruleId":"230","severity":1,"message":"330","line":94,"column":7,"nodeType":"232","messageId":"233","endLine":94,"endColumn":12},{"ruleId":"230","severity":1,"message":"331","line":1,"column":17,"nodeType":"232","messageId":"233","endLine":1,"endColumn":25},{"ruleId":"230","severity":1,"message":"300","line":1,"column":27,"nodeType":"232","messageId":"233","endLine":1,"endColumn":36},{"ruleId":"230","severity":1,"message":"332","line":1,"column":38,"nodeType":"232","messageId":"233","endLine":1,"endColumn":44},{"ruleId":"230","severity":1,"message":"257","line":1,"column":46,"nodeType":"232","messageId":"233","endLine":1,"endColumn":54},{"ruleId":"230","severity":1,"message":"258","line":3,"column":3,"nodeType":"232","messageId":"233","endLine":3,"endColumn":13},{"ruleId":"230","severity":1,"message":"271","line":4,"column":3,"nodeType":"232","messageId":"233","endLine":4,"endColumn":17},{"ruleId":"230","severity":1,"message":"259","line":5,"column":3,"nodeType":"232","messageId":"233","endLine":5,"endColumn":17},{"ruleId":"230","severity":1,"message":"333","line":6,"column":3,"nodeType":"232","messageId":"233","endLine":6,"endColumn":20},{"ruleId":"230","severity":1,"message":"334","line":9,"column":3,"nodeType":"232","messageId":"233","endLine":9,"endColumn":10},{"ruleId":"230","severity":1,"message":"285","line":10,"column":3,"nodeType":"232","messageId":"233","endLine":10,"endColumn":8},{"ruleId":"230","severity":1,"message":"286","line":11,"column":3,"nodeType":"232","messageId":"233","endLine":11,"endColumn":12},{"ruleId":"230","severity":1,"message":"287","line":12,"column":3,"nodeType":"232","messageId":"233","endLine":12,"endColumn":13},{"ruleId":"230","severity":1,"message":"288","line":13,"column":3,"nodeType":"232","messageId":"233","endLine":13,"endColumn":8},{"ruleId":"230","severity":1,"message":"261","line":14,"column":3,"nodeType":"232","messageId":"233","endLine":14,"endColumn":8},{"ruleId":"230","severity":1,"message":"335","line":15,"column":3,"nodeType":"232","messageId":"233","endLine":15,"endColumn":8},{"ruleId":"230","severity":1,"message":"289","line":16,"column":3,"nodeType":"232","messageId":"233","endLine":16,"endColumn":13},{"ruleId":"230","severity":1,"message":"336","line":17,"column":3,"nodeType":"232","messageId":"233","endLine":17,"endColumn":16},{"ruleId":"230","severity":1,"message":"291","line":18,"column":3,"nodeType":"232","messageId":"233","endLine":18,"endColumn":11},{"ruleId":"230","severity":1,"message":"292","line":19,"column":3,"nodeType":"232","messageId":"233","endLine":19,"endColumn":11},{"ruleId":"230","severity":1,"message":"293","line":20,"column":3,"nodeType":"232","messageId":"233","endLine":20,"endColumn":10},{"ruleId":"230","severity":1,"message":"337","line":21,"column":3,"nodeType":"232","messageId":"233","endLine":21,"endColumn":12},{"ruleId":"230","severity":1,"message":"294","line":22,"column":3,"nodeType":"232","messageId":"233","endLine":22,"endColumn":12},{"ruleId":"230","severity":1,"message":"338","line":23,"column":3,"nodeType":"232","messageId":"233","endLine":23,"endColumn":15},{"ruleId":"230","severity":1,"message":"339","line":24,"column":3,"nodeType":"232","messageId":"233","endLine":24,"endColumn":16},{"ruleId":"230","severity":1,"message":"295","line":25,"column":3,"nodeType":"232","messageId":"233","endLine":25,"endColumn":14},{"ruleId":"230","severity":1,"message":"340","line":26,"column":3,"nodeType":"232","messageId":"233","endLine":26,"endColumn":15},{"ruleId":"230","severity":1,"message":"341","line":27,"column":3,"nodeType":"232","messageId":"233","endLine":27,"endColumn":12},{"ruleId":"230","severity":1,"message":"342","line":28,"column":3,"nodeType":"232","messageId":"233","endLine":28,"endColumn":15},{"ruleId":"230","severity":1,"message":"343","line":31,"column":3,"nodeType":"232","messageId":"233","endLine":31,"endColumn":24},{"ruleId":"230","severity":1,"message":"344","line":32,"column":3,"nodeType":"232","messageId":"233","endLine":32,"endColumn":16},{"ruleId":"230","severity":1,"message":"345","line":33,"column":3,"nodeType":"232","messageId":"233","endLine":33,"endColumn":17},{"ruleId":"230","severity":1,"message":"346","line":34,"column":3,"nodeType":"232","messageId":"233","endLine":34,"endColumn":18},{"ruleId":"230","severity":1,"message":"347","line":37,"column":3,"nodeType":"232","messageId":"233","endLine":37,"endColumn":17},{"ruleId":"230","severity":1,"message":"231","line":38,"column":3,"nodeType":"232","messageId":"233","endLine":38,"endColumn":10},{"ruleId":"230","severity":1,"message":"234","line":39,"column":3,"nodeType":"232","messageId":"233","endLine":39,"endColumn":10},{"ruleId":"230","severity":1,"message":"348","line":40,"column":3,"nodeType":"232","messageId":"233","endLine":40,"endColumn":23},{"ruleId":"230","severity":1,"message":"349","line":42,"column":8,"nodeType":"232","messageId":"233","endLine":42,"endColumn":16},{"ruleId":"230","severity":1,"message":"350","line":43,"column":8,"nodeType":"232","messageId":"233","endLine":43,"endColumn":13},{"ruleId":"230","severity":1,"message":"235","line":44,"column":8,"nodeType":"232","messageId":"233","endLine":44,"endColumn":17},{"ruleId":"230","severity":1,"message":"351","line":45,"column":8,"nodeType":"232","messageId":"233","endLine":45,"endColumn":15},{"ruleId":"230","severity":1,"message":"266","line":46,"column":8,"nodeType":"232","messageId":"233","endLine":46,"endColumn":12},{"ruleId":"230","severity":1,"message":"267","line":47,"column":10,"nodeType":"232","messageId":"233","endLine":47,"endColumn":19},{"ruleId":"230","severity":1,"message":"352","line":47,"column":21,"nodeType":"232","messageId":"233","endLine":47,"endColumn":27},{"ruleId":"230","severity":1,"message":"353","line":48,"column":10,"nodeType":"232","messageId":"233","endLine":48,"endColumn":23},"no-native-reassign",["354"],"no-negated-in-lhs",["355"],"no-unused-vars","'useUndo' is defined but never used.","Identifier","unusedVar","'useRedo' is defined but never used.","'MobileBar' is defined but never used.","'h' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'barHeight' and 'sidebarWidth'. Either include them or remove the dependency array.","ArrayExpression",["356"],"'showPreview' is assigned a value but never used.","'images' is assigned a value but never used.","'getIsTrackingHistory' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'addImage', 'cols', 'mosaicCamera', 'rawSetImageMap', 'rows', 'scene_ref', 'setCameras', 'setImageMap', 'setIsTrackingHistory', and 'setScene'. Either include them or remove the dependency array.",["357"],"React Hook useEffect has a missing dependency: 'scene_ref'. Either include it or remove the dependency array.",["358"],"React Hook useEffect has a missing dependency: 'setScene'. Either include it or remove the dependency array.",["359"],"'ReadActive' is defined but never used.","'React' is defined but never used.","'zoom_scaler' is defined but never used.","'w' is assigned a value but never used.","'rows' is assigned a value but never used.","'_' is assigned a value but never used.","'__' is assigned a value but never used.","'useState' is defined but never used.","'RecoilRoot' is defined but never used.","'useRecoilValue' is defined but never used.","'useRecoilSnapshot' is defined but never used.","'aRows' is defined but never used.","'zoomMode' is assigned a value but never used.","'snapshot' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'activeEscape', 'addCol', 'addImage', 'addRow', 'check', 'copy', 'input_ref', 'logState', 'mosaicCamera', 'moveActive', 'panCamera', 'paste', 'pullCameras', 'pushCameras', 'redo', 'remCol', 'remRow', 'resetZoom', 'resizeActive', 'scene_ref', 'selectAll', 'setGridSize', 'setImageMap', 'setMode', 'setShowCameras', 'setShowGrid', 'setShowPreview', 'setZoomMode', 'shakeCamera', 'shatterCamera', 'undo', and 'zoomCamera'. Either include them or remove the dependency array.",["360"],"'REGL' is defined but never used.","'base_zoom' is defined but never used.","'transformPoint' is defined but never used.","'normalize' is defined but never used.","'viewport' is assigned a value but never used.","'useRecoilState' is defined but never used.","'draw' is defined but never used.","'debounce' is defined but never used.","'throttle' is defined but never used.","'startBatch' is assigned a value but never used.","'endBatch' is assigned a value but never used.","'scroll' is assigned a value but never used.","'ax' is assigned a value but never used.","'ay' is assigned a value but never used.","'aw' is assigned a value but never used.","'ah' is assigned a value but never used.","'filename' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'addImage', 'panCamera', 'scene_ref', 'scroll_ref', 'setActive', 'setImageMap', and 'zoomCamera'. Either include them or remove the dependency array.",["361"],"'aSize' is defined but never used.","'aGridSize' is defined but never used.","'sViewports' is defined but never used.","'aCols' is defined but never used.","'aBarHeight' is defined but never used.","'aSidebar' is defined but never used.","'aCameras' is defined but never used.","'afCamera' is defined but never used.","'aImages' is defined but never used.","'aImageMap' is defined but never used.","'sAllCameras' is defined but never used.","'km_ref' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'click'. Either include it or remove the dependency array.",["362"],["363"],"'useEffect' is defined but never used.","'domLoadImage' is defined but never used.","'Spacer' is defined but never used.","'Tip' is defined but never used.","'sidebarWidth' is assigned a value but never used.","'showCameras' is assigned a value but never used.","'setShowCameras' is assigned a value but never used.","'showGrid' is assigned a value but never used.","'setShowGrid' is assigned a value but never used.","'setShowPreview' is assigned a value but never used.","'moveActive' is assigned a value but never used.","'resizeActive' is assigned a value but never used.","'panCamera' is assigned a value but never used.","'mosaicCamera' is assigned a value but never used.","'shatterCamera' is assigned a value but never used.","'shakeCamera' is assigned a value but never used.","'pushCameras' is assigned a value but never used.","'pullCameras' is assigned a value but never used.","'copy' is assigned a value but never used.","'paste' is assigned a value but never used.","'addCol' is assigned a value but never used.","'remCol' is assigned a value but never used.","'addRow' is assigned a value but never used.","'remRow' is assigned a value but never used.","'resetZoom' is assigned a value but never used.","'addImage' is assigned a value but never used.","'setImageMap' is assigned a value but never used.","'setGridSize' is assigned a value but never used.","'undo' is assigned a value but never used.","'redo' is assigned a value but never used.","'input' is assigned a value but never used.","'Fragment' is defined but never used.","'useRef' is defined but never used.","'useSetRecoilState' is defined but never used.","'aActive' is defined but never used.","'aMode' is defined but never used.","'aSidebarWidth' is defined but never used.","'sAddImage' is defined but never used.","'sSetImageMap' is defined but never used.","'sMosaicCamera' is defined but never used.","'aShowCameras' is defined but never used.","'aShowGrid' is defined but never used.","'aShowPreview' is defined but never used.","'setProjectionMatrices' is defined but never used.","'setViewMatrix' is defined but never used.","'getWorldFromPx' is defined but never used.","'setViewMatrices' is defined but never used.","'RecoilUndoRoot' is defined but never used.","'useIsTrackingHistory' is defined but never used.","'Keyboard' is defined but never used.","'Mouse' is defined but never used.","'Sidebar' is defined but never used.","'mobile' is defined but never used.","'initImageQuad' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"364","fix":"365"},{"desc":"366","fix":"367"},{"desc":"368","fix":"369"},{"desc":"370","fix":"371"},{"desc":"372","fix":"373"},{"desc":"374","fix":"375"},{"desc":"376","fix":"377"},{"desc":"376","fix":"378"},"Update the dependencies array to be: [setSize, setGridSize, sidebarWidth, barHeight]",{"range":"379","text":"380"},"Update the dependencies array to be: [addImage, cols, gridSize, loaded, mosaicCamera, rawSetImageMap, rows, scene_ref, setCameras, setImageMap, setIsTrackingHistory, setScene]",{"range":"381","text":"382"},"Update the dependencies array to be: [loaded, imageMap, scene_ref]",{"range":"383","text":"384"},"Update the dependencies array to be: [loaded, cols, rows, gridSize, viewports, cameras, setScene]",{"range":"385","text":"386"},"Update the dependencies array to be: [mode, showGrid, showCameras, showPreview, scene_ref, input_ref, check, undo, redo, logState, moveActive, panCamera, setMode, selectAll, activeEscape, zoomCamera, setZoomMode, addImage, setImageMap, copy, paste, shatterCamera, mosaicCamera, shakeCamera, pushCameras, pullCameras, resetZoom, setShowPreview, setShowGrid, setShowCameras, remCol, addCol, remRow, addRow, resizeActive, setGridSize]",{"range":"387","text":"388"},"Update the dependencies array to be: [viewports, mode, canvas_ref, active, cols, scene_ref, scroll_ref, setActive, panCamera, zoomCamera, addImage, setImageMap]",{"range":"389","text":"390"},"Update the dependencies array to be: [click]",{"range":"391","text":"392"},{"range":"393","text":"392"},[3520,3542],"[setSize, setGridSize, sidebarWidth, barHeight]",[13917,13935],"[addImage, cols, gridSize, loaded, mosaicCamera, rawSetImageMap, rows, scene_ref, setCameras, setImageMap, setIsTrackingHistory, setScene]",[14059,14077],"[loaded, imageMap, scene_ref]",[15053,15103],"[loaded, cols, rows, gridSize, viewports, cameras, setScene]",[6846,6888],"[mode, showGrid, showCameras, showPreview, scene_ref, input_ref, check, undo, redo, logState, moveActive, panCamera, setMode, selectAll, activeEscape, zoomCamera, setZoomMode, addImage, setImageMap, copy, paste, shatterCamera, mosaicCamera, shakeCamera, pushCameras, pullCameras, resetZoom, setShowPreview, setShowGrid, setShowCameras, remCol, addCol, remRow, addRow, resizeActive, setGridSize]",[6993,7036],"[viewports, mode, canvas_ref, active, cols, scene_ref, scroll_ref, setActive, panCamera, zoomCamera, addImage, setImageMap]",[16092,16094],"[click]",[17438,17440]]